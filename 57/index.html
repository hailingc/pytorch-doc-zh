



<!DOCTYPE html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="PyTorch 0.3.0 中文文档">
      
      
        <link rel="canonical" href="http://pytorch.apachecn.org/57/">
      
      
        <meta name="author" content="ApacheCN Team">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-3.0.3">
    
    
      
        <title>torch.nn - PyTorch 0.3.0 中文文档</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
      
      
        
        
        <meta name="theme-color" content="#ff7043">
      
    
    
      <script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    

    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
        }
    });
    </script>
    
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?38525fdac4b5d4403900b943d4e7dd91";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
    <!-- google webmaster -->
    <meta name="google-site-verification" content="pyo9N70ZWyh8JB43bIu633mhxesJ1IcwWCZlM3jUfFo" />
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="deep-orange" data-md-color-accent="deep-orange">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="../#torchnn" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="http://pytorch.apachecn.org" title="PyTorch 0.3.0 中文文档" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                PyTorch 0.3.0 中文文档
              </span>
              <span class="md-header-nav__topic">
                torch.nn
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/apachecn/pytorch-doc-zh/" title="前往 Github 仓库" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      pytorch-doc-zh
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    <li class="md-tabs__item">
      
        <a href=".." title="主页" class="md-tabs__link">
          主页
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../0/" title="中文教程" class="md-tabs__link">
          中文教程
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../45/" title="中文文档" class="md-tabs__link md-tabs__link--active">
          中文文档
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="http://pytorch.apachecn.org" title="PyTorch 0.3.0 中文文档" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    PyTorch 0.3.0 中文文档
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/apachecn/pytorch-doc-zh/" title="前往 Github 仓库" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      pytorch-doc-zh
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      主页
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        主页
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href=".." title="主页" class="md-nav__link">
      主页
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      中文教程
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        中文教程
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../0/" title="初学者教程" class="md-nav__link">
      初学者教程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../1/" title="PyTorch 深度学习: 60 分钟极速入门教程" class="md-nav__link">
      PyTorch 深度学习: 60 分钟极速入门教程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../2/" title="PyTorch 是什么？" class="md-nav__link">
      PyTorch 是什么？
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../3/" title="自动求导: 自动微分" class="md-nav__link">
      自动求导: 自动微分
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../4/" title="神经网络" class="md-nav__link">
      神经网络
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../5/" title="训练一个分类器" class="md-nav__link">
      训练一个分类器
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../6/" title="可选: 数据并行" class="md-nav__link">
      可选: 数据并行
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../7/" title="PyTorch for former Torch users" class="md-nav__link">
      PyTorch for former Torch users
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../8/" title="Tensors" class="md-nav__link">
      Tensors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../9/" title="Autograd (自动求导)" class="md-nav__link">
      Autograd (自动求导)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../10/" title="nn package" class="md-nav__link">
      nn package
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../11/" title="Multi-GPU examples" class="md-nav__link">
      Multi-GPU examples
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../12/" title="跟着例子学习 PyTorch" class="md-nav__link">
      跟着例子学习 PyTorch
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../13/" title="Warm-up: numpy" class="md-nav__link">
      Warm-up: numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../14/" title="PyTorch: Tensors" class="md-nav__link">
      PyTorch: Tensors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../15/" title="PyTorch: 变量和autograd" class="md-nav__link">
      PyTorch: 变量和autograd
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../16/" title="PyTorch: 定义新的autograd函数" class="md-nav__link">
      PyTorch: 定义新的autograd函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../17/" title="TensorFlow: 静态图" class="md-nav__link">
      TensorFlow: 静态图
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../18/" title="PyTorch: nn包" class="md-nav__link">
      PyTorch: nn包
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../19/" title="PyTorch: optim包" class="md-nav__link">
      PyTorch: optim包
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../20/" title="PyTorch: 定制化nn模块" class="md-nav__link">
      PyTorch: 定制化nn模块
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../21/" title="PyTorch: 动态控制流程 + 权重共享" class="md-nav__link">
      PyTorch: 动态控制流程 + 权重共享
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../22/" title="迁移学习教程" class="md-nav__link">
      迁移学习教程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../23/" title="数据加载和处理教程" class="md-nav__link">
      数据加载和处理教程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../24/" title="针对NLP的Pytorch深度学习" class="md-nav__link">
      针对NLP的Pytorch深度学习
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../25/" title="PyTorch介绍" class="md-nav__link">
      PyTorch介绍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../26/" title="PyTorch深度学习" class="md-nav__link">
      PyTorch深度学习
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../27/" title="词汇嵌入:编码词汇语义" class="md-nav__link">
      词汇嵌入:编码词汇语义
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../28/" title="序列模型和 LSTM 网络（长短记忆网络）" class="md-nav__link">
      序列模型和 LSTM 网络（长短记忆网络）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../29/" title="高级教程: 作出动态决策和 Bi-LSTM CRF" class="md-nav__link">
      高级教程: 作出动态决策和 Bi-LSTM CRF
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../30/" title="中级教程" class="md-nav__link">
      中级教程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../31/" title="用字符级RNN分类名称" class="md-nav__link">
      用字符级RNN分类名称
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../32/" title="基与字符级RNN（Char-RNN）的人名生成" class="md-nav__link">
      基与字符级RNN（Char-RNN）的人名生成
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../33/" title="用基于注意力机制的seq2seq神经网络进行翻译" class="md-nav__link">
      用基于注意力机制的seq2seq神经网络进行翻译
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../34/" title="强化学习（DQN）教程" class="md-nav__link">
      强化学习（DQN）教程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../35/" title="Writing Distributed Applications with PyTorch" class="md-nav__link">
      Writing Distributed Applications with PyTorch
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../36/" title="空间转换网络 (Spatial Transformer Networks) 教程" class="md-nav__link">
      空间转换网络 (Spatial Transformer Networks) 教程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../37/" title="高级教程" class="md-nav__link">
      高级教程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../38/" title="用 PyTorch 做 神经转换 (Neural Transfer)" class="md-nav__link">
      用 PyTorch 做 神经转换 (Neural Transfer)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../39/" title="使用 numpy 和 scipy 创建扩展" class="md-nav__link">
      使用 numpy 和 scipy 创建扩展
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../40/" title="使用 ONNX 将模型从 PyTorch 迁移到 Caffe2 和 Mobile" class="md-nav__link">
      使用 ONNX 将模型从 PyTorch 迁移到 Caffe2 和 Mobile
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../41/" title="为 pytorch 自定义 C 扩展" class="md-nav__link">
      为 pytorch 自定义 C 扩展
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../42/" title="项目相关" class="md-nav__link">
      项目相关
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../43/" title="项目贡献者" class="md-nav__link">
      项目贡献者
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../44/" title="组织学习交流群" class="md-nav__link">
      组织学习交流群
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      中文文档
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        中文文档
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../45/" title="介绍" class="md-nav__link">
      介绍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../46/" title="自动求导机制" class="md-nav__link">
      自动求导机制
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../47/" title="广播语义" class="md-nav__link">
      广播语义
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../48/" title="CUDA 语义" class="md-nav__link">
      CUDA 语义
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../49/" title="扩展 PyTorch" class="md-nav__link">
      扩展 PyTorch
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../50/" title="多进程的最佳实践" class="md-nav__link">
      多进程的最佳实践
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../51/" title="序列化语义" class="md-nav__link">
      序列化语义
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../52/" title="Package 参考" class="md-nav__link">
      Package 参考
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../53/" title="torch" class="md-nav__link">
      torch
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../54/" title="torch.Tensor" class="md-nav__link">
      torch.Tensor
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../55/" title="torch.sparse" class="md-nav__link">
      torch.sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../56/" title="torch.Storage" class="md-nav__link">
      torch.Storage
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        torch.nn
      </label>
    
    <a href="./" title="torch.nn" class="md-nav__link md-nav__link--active">
      torch.nn
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#parameters" title="Parameters (参数)" class="md-nav__link">
    Parameters (参数)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#containers" title="Containers (容器)" class="md-nav__link">
    Containers (容器)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#module" title="Module" class="md-nav__link">
    Module
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequential" title="Sequential" class="md-nav__link">
    Sequential
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modulelist" title="ModuleList" class="md-nav__link">
    ModuleList
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameterlist" title="ParameterList" class="md-nav__link">
    ParameterList
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#convolution-layers" title="Convolution Layers (卷积层)" class="md-nav__link">
    Convolution Layers (卷积层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#conv1d" title="Conv1d" class="md-nav__link">
    Conv1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conv2d" title="Conv2d" class="md-nav__link">
    Conv2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conv3d" title="Conv3d" class="md-nav__link">
    Conv3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose1d" title="ConvTranspose1d" class="md-nav__link">
    ConvTranspose1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose2d" title="ConvTranspose2d" class="md-nav__link">
    ConvTranspose2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose3d" title="ConvTranspose3d" class="md-nav__link">
    ConvTranspose3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pooling-layers" title="Pooling Layers (池化层)" class="md-nav__link">
    Pooling Layers (池化层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maxpool1d" title="MaxPool1d" class="md-nav__link">
    MaxPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxpool2d" title="MaxPool2d" class="md-nav__link">
    MaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxpool3d" title="MaxPool3d" class="md-nav__link">
    MaxPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool1d" title="MaxUnpool1d" class="md-nav__link">
    MaxUnpool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool2d" title="MaxUnpool2d" class="md-nav__link">
    MaxUnpool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool3d" title="MaxUnpool3d" class="md-nav__link">
    MaxUnpool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool1d" title="AvgPool1d" class="md-nav__link">
    AvgPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool2d" title="AvgPool2d" class="md-nav__link">
    AvgPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool3d" title="AvgPool3d" class="md-nav__link">
    AvgPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fractionalmaxpool2d" title="FractionalMaxPool2d" class="md-nav__link">
    FractionalMaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lppool2d" title="LPPool2d" class="md-nav__link">
    LPPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool1d" title="AdaptiveMaxPool1d" class="md-nav__link">
    AdaptiveMaxPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool2d" title="AdaptiveMaxPool2d" class="md-nav__link">
    AdaptiveMaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool3d" title="AdaptiveMaxPool3d" class="md-nav__link">
    AdaptiveMaxPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool1d" title="AdaptiveAvgPool1d" class="md-nav__link">
    AdaptiveAvgPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool2d" title="AdaptiveAvgPool2d" class="md-nav__link">
    AdaptiveAvgPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool3d" title="AdaptiveAvgPool3d" class="md-nav__link">
    AdaptiveAvgPool3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#padding-layers" title="Padding Layers (填充层)" class="md-nav__link">
    Padding Layers (填充层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reflectionpad2d" title="ReflectionPad2d" class="md-nav__link">
    ReflectionPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad2d" title="ReplicationPad2d" class="md-nav__link">
    ReplicationPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad3d" title="ReplicationPad3d" class="md-nav__link">
    ReplicationPad3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zeropad2d" title="ZeroPad2d" class="md-nav__link">
    ZeroPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constantpad2d" title="ConstantPad2d" class="md-nav__link">
    ConstantPad2d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#non-linear-activations" title="Non-linear Activations (非线性层)" class="md-nav__link">
    Non-linear Activations (非线性层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relu" title="ReLU" class="md-nav__link">
    ReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relu6" title="ReLU6" class="md-nav__link">
    ReLU6
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elu" title="ELU" class="md-nav__link">
    ELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selu" title="SELU" class="md-nav__link">
    SELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prelu" title="PReLU" class="md-nav__link">
    PReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leakyrelu" title="LeakyReLU" class="md-nav__link">
    LeakyReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#threshold" title="Threshold" class="md-nav__link">
    Threshold
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hardtanh" title="Hardtanh" class="md-nav__link">
    Hardtanh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sigmoid" title="Sigmoid" class="md-nav__link">
    Sigmoid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanh" title="Tanh" class="md-nav__link">
    Tanh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logsigmoid" title="LogSigmoid" class="md-nav__link">
    LogSigmoid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softplus" title="Softplus" class="md-nav__link">
    Softplus
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softshrink" title="Softshrink" class="md-nav__link">
    Softshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softsign" title="Softsign" class="md-nav__link">
    Softsign
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanhshrink" title="Tanhshrink" class="md-nav__link">
    Tanhshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmin" title="Softmin" class="md-nav__link">
    Softmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmax" title="Softmax" class="md-nav__link">
    Softmax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmax2d" title="Softmax2d" class="md-nav__link">
    Softmax2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logsoftmax" title="LogSoftmax" class="md-nav__link">
    LogSoftmax
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#normalization-layers" title="Normalization layers (归一化层)" class="md-nav__link">
    Normalization layers (归一化层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#batchnorm1d" title="BatchNorm1d" class="md-nav__link">
    BatchNorm1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batchnorm2d" title="BatchNorm2d" class="md-nav__link">
    BatchNorm2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batchnorm3d" title="BatchNorm3d" class="md-nav__link">
    BatchNorm3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm1d" title="InstanceNorm1d" class="md-nav__link">
    InstanceNorm1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm2d" title="InstanceNorm2d" class="md-nav__link">
    InstanceNorm2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm3d" title="InstanceNorm3d" class="md-nav__link">
    InstanceNorm3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recurrent-layers" title="Recurrent layers (循环层)" class="md-nav__link">
    Recurrent layers (循环层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rnn" title="RNN" class="md-nav__link">
    RNN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstm" title="LSTM" class="md-nav__link">
    LSTM
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gru" title="GRU" class="md-nav__link">
    GRU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rnncell" title="RNNCell" class="md-nav__link">
    RNNCell
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstmcell" title="LSTMCell" class="md-nav__link">
    LSTMCell
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grucell" title="GRUCell" class="md-nav__link">
    GRUCell
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linear-layers" title="Linear layers (线性层)" class="md-nav__link">
    Linear layers (线性层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linear" title="Linear" class="md-nav__link">
    Linear
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bilinear" title="Bilinear" class="md-nav__link">
    Bilinear
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dropout-layers" title="Dropout layers" class="md-nav__link">
    Dropout layers
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dropout" title="Dropout" class="md-nav__link">
    Dropout
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dropout2d" title="Dropout2d" class="md-nav__link">
    Dropout2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dropout3d" title="Dropout3d" class="md-nav__link">
    Dropout3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alphadropout" title="AlphaDropout" class="md-nav__link">
    AlphaDropout
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sparse-layers" title="Sparse layers (稀疏层)" class="md-nav__link">
    Sparse layers (稀疏层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#embedding" title="Embedding" class="md-nav__link">
    Embedding
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#embeddingbag" title="EmbeddingBag" class="md-nav__link">
    EmbeddingBag
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#distance-functions" title="Distance functions (距离函数)" class="md-nav__link">
    Distance functions (距离函数)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cosinesimilarity" title="CosineSimilarity" class="md-nav__link">
    CosineSimilarity
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pairwisedistance" title="PairwiseDistance" class="md-nav__link">
    PairwiseDistance
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#loss-functions" title="Loss functions (损失函数)" class="md-nav__link">
    Loss functions (损失函数)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l1loss" title="L1Loss" class="md-nav__link">
    L1Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mseloss" title="MSELoss" class="md-nav__link">
    MSELoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crossentropyloss" title="CrossEntropyLoss" class="md-nav__link">
    CrossEntropyLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nllloss" title="NLLLoss" class="md-nav__link">
    NLLLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poissonnllloss" title="PoissonNLLLoss" class="md-nav__link">
    PoissonNLLLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nllloss2d" title="NLLLoss2d" class="md-nav__link">
    NLLLoss2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kldivloss" title="KLDivLoss" class="md-nav__link">
    KLDivLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bceloss" title="BCELoss" class="md-nav__link">
    BCELoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcewithlogitsloss" title="BCEWithLogitsLoss" class="md-nav__link">
    BCEWithLogitsLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#marginrankingloss" title="MarginRankingLoss" class="md-nav__link">
    MarginRankingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hingeembeddingloss" title="HingeEmbeddingLoss" class="md-nav__link">
    HingeEmbeddingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multilabelmarginloss" title="MultiLabelMarginLoss" class="md-nav__link">
    MultiLabelMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smoothl1loss" title="SmoothL1Loss" class="md-nav__link">
    SmoothL1Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmarginloss" title="SoftMarginLoss" class="md-nav__link">
    SoftMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multilabelsoftmarginloss" title="MultiLabelSoftMarginLoss" class="md-nav__link">
    MultiLabelSoftMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosineembeddingloss" title="CosineEmbeddingLoss" class="md-nav__link">
    CosineEmbeddingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multimarginloss" title="MultiMarginLoss" class="md-nav__link">
    MultiMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tripletmarginloss" title="TripletMarginLoss" class="md-nav__link">
    TripletMarginLoss
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vision-layers" title="Vision layers (视觉层)" class="md-nav__link">
    Vision layers (视觉层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pixelshuffle" title="PixelShuffle" class="md-nav__link">
    PixelShuffle
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsample" title="Upsample" class="md-nav__link">
    Upsample
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsamplingnearest2d" title="UpsamplingNearest2d" class="md-nav__link">
    UpsamplingNearest2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsamplingbilinear2d" title="UpsamplingBilinear2d" class="md-nav__link">
    UpsamplingBilinear2d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dataparallel-layers-multi-gpu-distributed-gpu" title="DataParallel layers (multi-GPU, distributed) (数据并行层, 多 GPU 的, 分布式的)" class="md-nav__link">
    DataParallel layers (multi-GPU, distributed) (数据并行层, 多 GPU 的, 分布式的)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dataparallel" title="DataParallel" class="md-nav__link">
    DataParallel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distributeddataparallel" title="DistributedDataParallel" class="md-nav__link">
    DistributedDataParallel
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#utilities" title="Utilities (工具包)" class="md-nav__link">
    Utilities (工具包)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#clip_grad_norm" title="clip_grad_norm" class="md-nav__link">
    clip_grad_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weight_norm" title="weight_norm" class="md-nav__link">
    weight_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_weight_norm" title="remove_weight_norm" class="md-nav__link">
    remove_weight_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#packedsequence" title="PackedSequence" class="md-nav__link">
    PackedSequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pack_padded_sequence" title="pack_padded_sequence" class="md-nav__link">
    pack_padded_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pad_packed_sequence" title="pad_packed_sequence" class="md-nav__link">
    pad_packed_sequence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../58/" title="torch.optim" class="md-nav__link">
      torch.optim
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../59/" title="Automatic differentiation package - torch.autograd" class="md-nav__link">
      Automatic differentiation package - torch.autograd
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../60/" title="Probability distributions - torch.distributions" class="md-nav__link">
      Probability distributions - torch.distributions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../61/" title="Multiprocessing package - torch.multiprocessing" class="md-nav__link">
      Multiprocessing package - torch.multiprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../62/" title="Distributed communication package - torch.distributed" class="md-nav__link">
      Distributed communication package - torch.distributed
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../63/" title="Legacy package - torch.legacy" class="md-nav__link">
      Legacy package - torch.legacy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../64/" title="torch.cuda" class="md-nav__link">
      torch.cuda
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../65/" title="torch.utils.ffi" class="md-nav__link">
      torch.utils.ffi
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../66/" title="torch.utils.data" class="md-nav__link">
      torch.utils.data
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../67/" title="torch.utils.model_zoo" class="md-nav__link">
      torch.utils.model_zoo
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../68/" title="torch.onnx" class="md-nav__link">
      torch.onnx
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../69/" title="torchvision 参考" class="md-nav__link">
      torchvision 参考
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../70/" title="torchvision" class="md-nav__link">
      torchvision
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../71/" title="torchvision.datasets" class="md-nav__link">
      torchvision.datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../72/" title="torchvision.models" class="md-nav__link">
      torchvision.models
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../73/" title="torchvision.transforms" class="md-nav__link">
      torchvision.transforms
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../74/" title="torchvision.utils" class="md-nav__link">
      torchvision.utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../75/" title="项目相关" class="md-nav__link">
      项目相关
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../76/" title="项目贡献者" class="md-nav__link">
      项目贡献者
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../77/" title="组织学习交流群" class="md-nav__link">
      组织学习交流群
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#parameters" title="Parameters (参数)" class="md-nav__link">
    Parameters (参数)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#containers" title="Containers (容器)" class="md-nav__link">
    Containers (容器)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#module" title="Module" class="md-nav__link">
    Module
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequential" title="Sequential" class="md-nav__link">
    Sequential
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modulelist" title="ModuleList" class="md-nav__link">
    ModuleList
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameterlist" title="ParameterList" class="md-nav__link">
    ParameterList
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#convolution-layers" title="Convolution Layers (卷积层)" class="md-nav__link">
    Convolution Layers (卷积层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#conv1d" title="Conv1d" class="md-nav__link">
    Conv1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conv2d" title="Conv2d" class="md-nav__link">
    Conv2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conv3d" title="Conv3d" class="md-nav__link">
    Conv3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose1d" title="ConvTranspose1d" class="md-nav__link">
    ConvTranspose1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose2d" title="ConvTranspose2d" class="md-nav__link">
    ConvTranspose2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose3d" title="ConvTranspose3d" class="md-nav__link">
    ConvTranspose3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pooling-layers" title="Pooling Layers (池化层)" class="md-nav__link">
    Pooling Layers (池化层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maxpool1d" title="MaxPool1d" class="md-nav__link">
    MaxPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxpool2d" title="MaxPool2d" class="md-nav__link">
    MaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxpool3d" title="MaxPool3d" class="md-nav__link">
    MaxPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool1d" title="MaxUnpool1d" class="md-nav__link">
    MaxUnpool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool2d" title="MaxUnpool2d" class="md-nav__link">
    MaxUnpool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool3d" title="MaxUnpool3d" class="md-nav__link">
    MaxUnpool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool1d" title="AvgPool1d" class="md-nav__link">
    AvgPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool2d" title="AvgPool2d" class="md-nav__link">
    AvgPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool3d" title="AvgPool3d" class="md-nav__link">
    AvgPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fractionalmaxpool2d" title="FractionalMaxPool2d" class="md-nav__link">
    FractionalMaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lppool2d" title="LPPool2d" class="md-nav__link">
    LPPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool1d" title="AdaptiveMaxPool1d" class="md-nav__link">
    AdaptiveMaxPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool2d" title="AdaptiveMaxPool2d" class="md-nav__link">
    AdaptiveMaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool3d" title="AdaptiveMaxPool3d" class="md-nav__link">
    AdaptiveMaxPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool1d" title="AdaptiveAvgPool1d" class="md-nav__link">
    AdaptiveAvgPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool2d" title="AdaptiveAvgPool2d" class="md-nav__link">
    AdaptiveAvgPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool3d" title="AdaptiveAvgPool3d" class="md-nav__link">
    AdaptiveAvgPool3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#padding-layers" title="Padding Layers (填充层)" class="md-nav__link">
    Padding Layers (填充层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reflectionpad2d" title="ReflectionPad2d" class="md-nav__link">
    ReflectionPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad2d" title="ReplicationPad2d" class="md-nav__link">
    ReplicationPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad3d" title="ReplicationPad3d" class="md-nav__link">
    ReplicationPad3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zeropad2d" title="ZeroPad2d" class="md-nav__link">
    ZeroPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constantpad2d" title="ConstantPad2d" class="md-nav__link">
    ConstantPad2d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#non-linear-activations" title="Non-linear Activations (非线性层)" class="md-nav__link">
    Non-linear Activations (非线性层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relu" title="ReLU" class="md-nav__link">
    ReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relu6" title="ReLU6" class="md-nav__link">
    ReLU6
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#elu" title="ELU" class="md-nav__link">
    ELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selu" title="SELU" class="md-nav__link">
    SELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prelu" title="PReLU" class="md-nav__link">
    PReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leakyrelu" title="LeakyReLU" class="md-nav__link">
    LeakyReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#threshold" title="Threshold" class="md-nav__link">
    Threshold
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hardtanh" title="Hardtanh" class="md-nav__link">
    Hardtanh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sigmoid" title="Sigmoid" class="md-nav__link">
    Sigmoid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanh" title="Tanh" class="md-nav__link">
    Tanh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logsigmoid" title="LogSigmoid" class="md-nav__link">
    LogSigmoid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softplus" title="Softplus" class="md-nav__link">
    Softplus
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softshrink" title="Softshrink" class="md-nav__link">
    Softshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softsign" title="Softsign" class="md-nav__link">
    Softsign
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanhshrink" title="Tanhshrink" class="md-nav__link">
    Tanhshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmin" title="Softmin" class="md-nav__link">
    Softmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmax" title="Softmax" class="md-nav__link">
    Softmax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmax2d" title="Softmax2d" class="md-nav__link">
    Softmax2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logsoftmax" title="LogSoftmax" class="md-nav__link">
    LogSoftmax
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#normalization-layers" title="Normalization layers (归一化层)" class="md-nav__link">
    Normalization layers (归一化层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#batchnorm1d" title="BatchNorm1d" class="md-nav__link">
    BatchNorm1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batchnorm2d" title="BatchNorm2d" class="md-nav__link">
    BatchNorm2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batchnorm3d" title="BatchNorm3d" class="md-nav__link">
    BatchNorm3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm1d" title="InstanceNorm1d" class="md-nav__link">
    InstanceNorm1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm2d" title="InstanceNorm2d" class="md-nav__link">
    InstanceNorm2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm3d" title="InstanceNorm3d" class="md-nav__link">
    InstanceNorm3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recurrent-layers" title="Recurrent layers (循环层)" class="md-nav__link">
    Recurrent layers (循环层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rnn" title="RNN" class="md-nav__link">
    RNN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstm" title="LSTM" class="md-nav__link">
    LSTM
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gru" title="GRU" class="md-nav__link">
    GRU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rnncell" title="RNNCell" class="md-nav__link">
    RNNCell
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstmcell" title="LSTMCell" class="md-nav__link">
    LSTMCell
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grucell" title="GRUCell" class="md-nav__link">
    GRUCell
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linear-layers" title="Linear layers (线性层)" class="md-nav__link">
    Linear layers (线性层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linear" title="Linear" class="md-nav__link">
    Linear
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bilinear" title="Bilinear" class="md-nav__link">
    Bilinear
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dropout-layers" title="Dropout layers" class="md-nav__link">
    Dropout layers
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dropout" title="Dropout" class="md-nav__link">
    Dropout
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dropout2d" title="Dropout2d" class="md-nav__link">
    Dropout2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dropout3d" title="Dropout3d" class="md-nav__link">
    Dropout3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alphadropout" title="AlphaDropout" class="md-nav__link">
    AlphaDropout
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sparse-layers" title="Sparse layers (稀疏层)" class="md-nav__link">
    Sparse layers (稀疏层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#embedding" title="Embedding" class="md-nav__link">
    Embedding
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#embeddingbag" title="EmbeddingBag" class="md-nav__link">
    EmbeddingBag
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#distance-functions" title="Distance functions (距离函数)" class="md-nav__link">
    Distance functions (距离函数)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cosinesimilarity" title="CosineSimilarity" class="md-nav__link">
    CosineSimilarity
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pairwisedistance" title="PairwiseDistance" class="md-nav__link">
    PairwiseDistance
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#loss-functions" title="Loss functions (损失函数)" class="md-nav__link">
    Loss functions (损失函数)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l1loss" title="L1Loss" class="md-nav__link">
    L1Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mseloss" title="MSELoss" class="md-nav__link">
    MSELoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crossentropyloss" title="CrossEntropyLoss" class="md-nav__link">
    CrossEntropyLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nllloss" title="NLLLoss" class="md-nav__link">
    NLLLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poissonnllloss" title="PoissonNLLLoss" class="md-nav__link">
    PoissonNLLLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nllloss2d" title="NLLLoss2d" class="md-nav__link">
    NLLLoss2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kldivloss" title="KLDivLoss" class="md-nav__link">
    KLDivLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bceloss" title="BCELoss" class="md-nav__link">
    BCELoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcewithlogitsloss" title="BCEWithLogitsLoss" class="md-nav__link">
    BCEWithLogitsLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#marginrankingloss" title="MarginRankingLoss" class="md-nav__link">
    MarginRankingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hingeembeddingloss" title="HingeEmbeddingLoss" class="md-nav__link">
    HingeEmbeddingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multilabelmarginloss" title="MultiLabelMarginLoss" class="md-nav__link">
    MultiLabelMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smoothl1loss" title="SmoothL1Loss" class="md-nav__link">
    SmoothL1Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmarginloss" title="SoftMarginLoss" class="md-nav__link">
    SoftMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multilabelsoftmarginloss" title="MultiLabelSoftMarginLoss" class="md-nav__link">
    MultiLabelSoftMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosineembeddingloss" title="CosineEmbeddingLoss" class="md-nav__link">
    CosineEmbeddingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multimarginloss" title="MultiMarginLoss" class="md-nav__link">
    MultiMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tripletmarginloss" title="TripletMarginLoss" class="md-nav__link">
    TripletMarginLoss
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vision-layers" title="Vision layers (视觉层)" class="md-nav__link">
    Vision layers (视觉层)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pixelshuffle" title="PixelShuffle" class="md-nav__link">
    PixelShuffle
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsample" title="Upsample" class="md-nav__link">
    Upsample
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsamplingnearest2d" title="UpsamplingNearest2d" class="md-nav__link">
    UpsamplingNearest2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsamplingbilinear2d" title="UpsamplingBilinear2d" class="md-nav__link">
    UpsamplingBilinear2d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dataparallel-layers-multi-gpu-distributed-gpu" title="DataParallel layers (multi-GPU, distributed) (数据并行层, 多 GPU 的, 分布式的)" class="md-nav__link">
    DataParallel layers (multi-GPU, distributed) (数据并行层, 多 GPU 的, 分布式的)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dataparallel" title="DataParallel" class="md-nav__link">
    DataParallel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distributeddataparallel" title="DistributedDataParallel" class="md-nav__link">
    DistributedDataParallel
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#utilities" title="Utilities (工具包)" class="md-nav__link">
    Utilities (工具包)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#clip_grad_norm" title="clip_grad_norm" class="md-nav__link">
    clip_grad_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weight_norm" title="weight_norm" class="md-nav__link">
    weight_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_weight_norm" title="remove_weight_norm" class="md-nav__link">
    remove_weight_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#packedsequence" title="PackedSequence" class="md-nav__link">
    PackedSequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pack_padded_sequence" title="pack_padded_sequence" class="md-nav__link">
    pack_padded_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pad_packed_sequence" title="pad_packed_sequence" class="md-nav__link">
    pad_packed_sequence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/apachecn/pytorch-doc-zh/edit/master/docs/57.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="torchnn">torch.nn</h1>
<h2 id="parameters">Parameters (参数)</h2>
<pre class="codehilite"><code class="language-py">class torch.nn.Parameter</code></pre>


<p>Variable 的一种, 常被用于 module parameter（模块参数）.</p>
<p>Parameters 是 <a href="autograd.html#torch.autograd.Variable" title="torch.autograd.Variable"><code>Variable</code></a> 的子类, 当它和 <a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> 一起使用的时候会有一些特殊的属性 - 当它们被赋值给 Module 属性时, 它会自动的被加到 Module 的参数列表中, 并且会出现在 <a href="#torch.nn.Module.parameters" title="torch.nn.Module.parameters"><code>parameters()</code></a> iterator 迭代器方法中. 将 Varibale 赋值给 Module 属性则不会有这样的影响. 这样做的原因是: 我们有时候会需要缓存一些临时的 state（状态）, 例如: 模型 RNN 中的最后一个隐藏状态. 如果没有 <a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a> 这个类的话, 那么这些临时表也会注册为模型变量.</p>
<p>Variable 与 Parameter 的另一个不同之处在于, Parameter 不能被 volatile (即: 无法设置 volatile=True) 而且默认 requires_grad=True. Variable 默认 requires_grad=False.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>data</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – parameter tensor.</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果参数需要梯度. 更多细节请参阅 <a href="notes/autograd.html#excluding-subgraphs">反向排除 subgraphs (子图)</a>.</li>
</ul>
<p>|
| --- | --- |</p>
<h2 id="containers">Containers (容器)</h2>
<h3 id="module">Module</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Module</code></pre>


<p>所有神经网络的基类.</p>
<p>你的模型应该也是该类的子类.</p>
<p>Modules 也可以包含其它 Modules, 允许使用树结构嵌入它们. 你可以将子模块赋值给模型属性</p>
<pre class="codehilite"><code class="language-py">import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
       x = F.relu(self.conv1(x))
       return F.relu(self.conv2(x))</code></pre>


<p>以这种方式分配的子模块将被注册, 并且在调用 .cuda() 等等方法时也将转换它们的参数.</p>
<pre class="codehilite"><code class="language-py">add_module(name, module)</code></pre>


<p>添加一个 child module（子模块）到当前的 module（模块）中.</p>
<p>被添加的 module 还可以通过指定的 name 属性来获取它.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.6)"><em>string</em></a>) – 子模块的名称. 可以使用指定的 name 从该模块访问子模块</li>
<li><strong>parameter</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – 被添加到模块的子模块.</li>
</ul>
<p>|
| --- | --- |</p>
<pre class="codehilite"><code class="language-py">apply(fn)</code></pre>


<p>将 <code>fn</code> 函数递归的应用到每一个子模块 (由 <code>.children()</code> 方法所返回的) 以及 self. 典型的用于包括初始化模型的参数 (也可参阅 torch-nn-init).</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>fn</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> -&gt; None) – 要被应用到每一个子模块上的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>self</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Example</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; def init_weights(m):
&gt;&gt;&gt;     print(m)
&gt;&gt;&gt;     if type(m) == nn.Linear:
&gt;&gt;&gt;         m.weight.data.fill_(1.0)
&gt;&gt;&gt;         print(m.weight)
&gt;&gt;&gt;
&gt;&gt;&gt; net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
&gt;&gt;&gt; net.apply(init_weights)
Linear (2 -&gt; 2)
Parameter containing:
 1  1
 1  1
[torch.FloatTensor of size 2x2]
Linear (2 -&gt; 2)
Parameter containing:
 1  1
 1  1
[torch.FloatTensor of size 2x2]
Sequential (
 (0): Linear (2 -&gt; 2)
 (1): Linear (2 -&gt; 2)
)</code></pre>


<pre class="codehilite"><code class="language-py">children()</code></pre>


<p>返回一个最近子模块的 iterator（迭代器）.</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>Module</em> – 一个子模块</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">cpu()</code></pre>


<p>将所有的模型参数和缓冲区移动到 CPU.</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">cuda(device=None)</code></pre>


<p>将所有的模型参数和缓冲区移动到 GPU.</p>
<p>这将会关联一些参数并且缓存不同的对象. 所以在构建优化器之前应该调用它, 如果模块在优化的情况下会生存在 GPU 上.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>device</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <em>optional</em>) – 如果指定, 所有参数将被复制到指定的设备上</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>self</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">double()</code></pre>


<p>将所有的 parameters 和 buffers 的数据类型转换成 double.</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">eval()</code></pre>


<p>将模块设置为评估模式.</p>
<p>这种方式只对 Dropout 或 BatchNorm 等模块有效.</p>
<pre class="codehilite"><code class="language-py">float()</code></pre>


<p>将所有的 parameters 和 buffers 的数据类型转换成float.</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">forward(*input)</code></pre>


<p>定义每次调用时执行的计算.</p>
<p>应该被所有的子类重写.</p>
<p>Note</p>
<p>尽管需要在此函数中定义正向传递的方式, 但是应该事后尽量调用 <a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> 实例, 因为前者负责运行已注册的钩子, 而后者静默的忽略它们.</p>
<pre class="codehilite"><code class="language-py">half()</code></pre>


<p>将所有的 parameters 和 buffers 的数据类型转换成 half.</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">load_state_dict(state_dict, strict=True)</code></pre>


<p>将 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict</code></a> 中的 parameters 和 buffers 复制到此模块和它的子后代中. 如果 <code>strict</code> 为 <code>True</code>, 则 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict</code></a> 的 key 必须和模块的 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict()</code></a> 函数返回的 key 一致.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>state_dict</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)"><em>dict</em></a>) – 一个包含 parameters 和 persistent buffers（持久化缓存的）字典.</li>
<li><strong>strict</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a>) – 严格的强制 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict</code></a> 属性中的 key 与该模块的函数 &lt;cite&gt;:func:`state_dict()&lt;/cite&gt; 返回的 keys 相匹配.</li>
</ul>
<p>|
| --- | --- |</p>
<pre class="codehilite"><code class="language-py">modules()</code></pre>


<p>返回一个覆盖神经网络中所有模块的 iterator（迭代器）.</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>Module</em> – a module in the network</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>重复的模块只返回一次. 在下面的例子中, <code>1</code> 只会被返回一次. example, <code>l</code> will be returned only once.</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.modules()):
&gt;&gt;&gt;     print(idx, '-&gt;', m)
0 -&gt; Sequential (
 (0): Linear (2 -&gt; 2)
 (1): Linear (2 -&gt; 2)
)
1 -&gt; Linear (2 -&gt; 2)</code></pre>


<pre class="codehilite"><code class="language-py">named_children()</code></pre>


<p>返回一个 iterator（迭代器）, 而不是最接近的子模块, 产生模块的 name 以及模块本身.</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, Module)</em> – 包含名称和子模块的 Tuple（元组）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; for name, module in model.named_children():
&gt;&gt;&gt;     if name in ['conv4', 'conv5']:
&gt;&gt;&gt;         print(module)</code></pre>


<pre class="codehilite"><code class="language-py">named_modules(memo=None, prefix='')</code></pre>


<p>返回一个神经网络中所有模块的 iterator（迭代器）, 产生模块的 name 以及模块本身.</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, Module)</em> – 名字和模块的 Tuple（元组）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>重复的模块只返回一次. 在下面的例子中, <code>1</code> 只会被返回一次.</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.named_modules()):
&gt;&gt;&gt;     print(idx, '-&gt;', m)
0 -&gt; ('', Sequential (
 (0): Linear (2 -&gt; 2)
 (1): Linear (2 -&gt; 2)
))
1 -&gt; ('0', Linear (2 -&gt; 2))</code></pre>


<pre class="codehilite"><code class="language-py">named_parameters(memo=None, prefix='')</code></pre>


<p>返回模块参数的迭代器, 产生参数的名称以及参数本身</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, Parameter)</em> – Tuple 包含名称很参数的 Tuple（元组）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; for name, param in self.named_parameters():
&gt;&gt;&gt;    if name in ['bias']:
&gt;&gt;&gt;        print(param.size())</code></pre>


<pre class="codehilite"><code class="language-py">parameters()</code></pre>


<p>返回一个模块参数的迭代器.</p>
<p>这通常传递给优化器.</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>Parameter</em> – 模型参数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; for param in model.parameters():
&gt;&gt;&gt;     print(type(param.data), param.size())
&lt;class 'torch.FloatTensor'&gt; (20L,)
&lt;class 'torch.FloatTensor'&gt; (20L, 1L, 5L, 5L)</code></pre>


<pre class="codehilite"><code class="language-py">register_backward_hook(hook)</code></pre>


<p>在模块上注册一个 backward hook（反向钩子）.</p>
<p>每次计算关于模块输入的梯度时, 都会调用该钩子. 钩子应该有以下结构:</p>
<pre class="codehilite"><code class="language-py">hook(module, grad_input, grad_output) -&gt; Tensor or None</code></pre>


<p>如果 module 有多个输入或输出的话, 那么 <code>grad_input</code> 和 <code>grad_output</code> 将会是个 tuple. hook 不应该修改它的参数, 但是它可以选择性地返回一个新的关于输入的梯度, 这个返回的梯度在后续的计算中会替代 <code>grad_input</code>.</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>通过调用 <code>handle.remove()</code> 方法可以删除添加钩子的句柄 <code>handle.remove()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><code>torch.utils.hooks.RemovableHandle</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">register_buffer(name, tensor)</code></pre>


<p>给模块添加一个持久化的 buffer.</p>
<p>持久化的 buffer 通常被用在这么一种情况: 我们需要保存一个状态, 但是这个状态不能看作成为模型参数. 例如: BatchNorm 的 <code>running_mean</code> 不是一个 parameter, 但是它也是需要保存的状态之一.</p>
<p>Buffers 可以使用指定的 name 作为属性访问.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.6)"><em>string</em></a>) – buffer 的名称. 可以使用指定的 name 从该模块访问 buffer</li>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 被注册的 buffer.</li>
</ul>
<p>|
| --- | --- |</p>
<p>Example</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; self.register_buffer('running_mean', torch.zeros(num_features))</code></pre>


<pre class="codehilite"><code class="language-py">register_forward_hook(hook)</code></pre>


<p>在模块上注册一个 forward hook（前向钩子）.</p>
<p>每一次 <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a> 函数计算出一个输出后, 该钩子将会被调用. 它应该具有以下结构</p>
<pre class="codehilite"><code class="language-py">hook(module, input, output) -&gt; None</code></pre>


<p>该钩子应该不会修改输入或输出.</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>通过调用 <code>handle.remove()</code> 方法可以删除添加钩子的句柄</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><code>torch.utils.hooks.RemovableHandle</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">register_forward_pre_hook(hook)</code></pre>


<p>在模块上注册一个预前向钩子.</p>
<p>每一次在调用 <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a> 函数前都会调用该钩子. 它应该有以下结构:</p>
<pre class="codehilite"><code class="language-py">hook(module, input) -&gt; None</code></pre>


<p>该钩子不应该修改输入.</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>通过调用 <code>handle.remove()</code> 方法可以删除添加钩子的句柄 <code>handle.remove()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><code>torch.utils.hooks.RemovableHandle</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">register_parameter(name, param)</code></pre>


<p>添加一个参数到模块中.</p>
<p>可以使用指定的 name 属性来访问参数.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.6)"><em>string</em></a>) – 参数名. 可以使用指定的 name 来从该模块中访问参数</li>
<li><strong>parameter</strong> (<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><em>Parameter</em></a>) – 要被添加到模块的参数.</li>
</ul>
<p>|
| --- | --- |</p>
<pre class="codehilite"><code class="language-py">state_dict(destination=None, prefix='', keep_vars=False)</code></pre>


<p>返回一个字典, 它包含整个模块的状态.</p>
<p>包括参数和持久化的缓冲区 (例如. 运行中的平均值). Keys 是与之对应的参数和缓冲区的 name.</p>
<p>当 keep_vars 为 <code>True</code> 时, 它为每一个参数（而不是一个张量）返回一个 Variable.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>destination</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)"><em>dict</em></a><em>,</em> <em>optional</em>) – 如果不是 None, 该返回的字典应该被存储到 destination 中. Default: None</li>
<li><strong>prefix</strong> (<a href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.6)"><em>string</em></a><em>,</em> <em>optional</em>) – 向结果字典中的每个参数和缓冲区的 key（名称）添加一个前缀. Default: ‘’</li>
<li><strong>keep_vars</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果为 <code>True</code>, 为每一个参数返回一个 Variable. 如果为 <code>False</code>, 为每一个参数返回一个 Tensor. Default: <code>False</code></li>
</ul>
<p>|
| --- | --- |
| Returns: | 包含模块整体状态的字典 |
| --- | --- |
| Return type: | <a href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.6)">dict</a> |
| --- | --- |</p>
<p>Example</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; module.state_dict().keys()
['bias', 'weight']</code></pre>


<pre class="codehilite"><code class="language-py">train(mode=True)</code></pre>


<p>设置模块为训练模式.</p>
<p>这只对诸如 Dropout 或 BatchNorm 等模块时才会有影响.</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">type(dst_type)</code></pre>


<p>转换所有参数和缓冲区为 dst_type.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>dst_type</strong> (<a href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.6)"><em>type</em></a> <em>or</em> <a href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.6)"><em>string</em></a>) – 理想的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>self</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">zero_grad()</code></pre>


<p>将所有模型参数的梯度设置为零.</p>
<h3 id="sequential">Sequential</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Sequential(*args)</code></pre>


<p>一个顺序的容器. 模块将按照它们在构造函数中传递的顺序添加到它. 或者, 也可以传入模块的有序字典.</p>
<p>为了更容易理解, 列举小例来说明</p>
<pre class="codehilite"><code class="language-py"># 使用 Sequential 的例子
model = nn.Sequential(
          nn.Conv2d(1,20,5),
          nn.ReLU(),
          nn.Conv2d(20,64,5),
          nn.ReLU()
        )

# 与 OrderedDict 一起使用 Sequential 的例子
model = nn.Sequential(OrderedDict([
          ('conv1', nn.Conv2d(1,20,5)),
          ('relu1', nn.ReLU()),
          ('conv2', nn.Conv2d(20,64,5)),
          ('relu2', nn.ReLU())
        ]))</code></pre>


<h3 id="modulelist">ModuleList</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ModuleList(modules=None)</code></pre>


<p>将子模块放入一个 list 中.</p>
<p>ModuleList 可以像普通的 Python list 一样被索引, 但是它包含的模块已经被正确的注册了, 并且所有的 Module 方法都是可见的.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.6)"><em>list</em></a><em>,</em> <em>optional</em>) – 要添加的模块列表</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.linears = nn.ModuleList([nn.Linear(10, 10) for i in range(10)])

    def forward(self, x):
        # ModuleList can act as an iterable, or be indexed using ints
        for i, l in enumerate(self.linears):
            x = self.linears[i // 2](x) + l(x)
        return x</code></pre>


<pre class="codehilite"><code class="language-py">append(module)</code></pre>


<p>添加一个指定的模块到 list 尾部.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – 要被添加的模块</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">extend(modules)</code></pre>


<p>在最后添加 Python list 中的模块.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.6)"><em>list</em></a>) – 要被添加的模块列表</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="parameterlist">ParameterList</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ParameterList(parameters=None)</code></pre>


<p>保存 list 中的 parameter.</p>
<p>ParameterList 可以像普通的 Python list 那样被索引, 但是它所包含的参数被正确的注册了, 并且所有的 Module 方法都可见的.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.6)"><em>list</em></a><em>,</em> <em>optional</em>) – 要被添加的 `Parameter`` 列表</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.params = nn.ParameterList([nn.Parameter(torch.randn(10, 10)) for i in range(10)])

    def forward(self, x):
        # ModuleList 可以充当 iterable（迭代器）, 或者可以使用整数进行索引
        for i, p in enumerate(self.params):
            x = self.params[i // 2].mm(x) + p.mm(x)
        return x</code></pre>


<pre class="codehilite"><code class="language-py">append(parameter)</code></pre>


<p>添加一个指定的参数到 list 尾部.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameter</strong> (<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><em>nn.Parameter</em></a>) – parameter to append</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre class="codehilite"><code class="language-py">extend(parameters)</code></pre>


<p>在最后添加 Python list 中的参数.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.6)"><em>list</em></a>) – list of parameters to append</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="convolution-layers">Convolution Layers (卷积层)</h2>
<h3 id="conv1d">Conv1d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)</code></pre>


<p>一维卷积层 输入矩阵的维度为 <code>\((N, C_{in}, L)\)</code>, 输出矩阵维度为 <code>\((N, C_{out}, L_{out})\)</code>. 其中N为输入数量, C为每个输入样本的通道数量, L为样本中一个通道下的数据的长度. 算法如下:</p>
<pre class="codehilite"><code class="language-py">\[\begin{array}{ll} out(N_i, C_{out_j}) = bias(C_{out_j}) + \sum_{{k}=0}^{C_{in}-1} weight(C_{out_j}, k) \star input(N_i, k) \end{array}\]</code></pre>


<p><code>\(\star\)</code> 是互相关运算符, 上式带 <code>\(\star\)</code> 项为卷积项.</p>
<p><code>stride</code> 计算相关系数的步长, 可以为 tuple .<code>padding</code> 处理边界时在两侧补0数量<code>dilation</code> 采样间隔数量. 大于1时为非致密采样, 如对(a,b,c,d,e)采样时, 若池化规模为2,</p>
<p>dilation 为1时, 使用 (a,b);(b,c)… 进行池化, dilation 为1时, 使用 (a,c);(b,d)… 进行池化. | <code>groups</code> 控制输入和输出之间的连接, group=1, 输出是所有输入的卷积；group=2, 此时相当于 有并排的两个卷基层, 每个卷积层只在对应的输入通道和输出通道之间计算, 并且输出时会将所有 输出通道简单的首尾相接作为结果输出.</p>
<blockquote>
<p>&lt;cite&gt;in_channels&lt;/cite&gt; 和 [<code>](#id1)out_channels</code>都要可以被 groups 整除.</p>
</blockquote>
<p>Note</p>
<p>数据的最后一列可能会因为 kernal 大小设定不当而被丢弃（大部分发生在 kernal 大小不能被输入 整除的时候, 适当的 padding 可以避免这个问题）.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>in_channels</strong> (<em>-</em>) – 输入信号的通道数.</li>
<li><strong>out_channels</strong> (<em>-</em>) – 卷积后输出结果的通道数.</li>
<li><strong>kernel_size</strong> (<em>-</em>) – 卷积核的形状.</li>
<li><strong>stride</strong> (<em>-</em>) – 卷积每次移动的步长, 默认为1.</li>
<li><strong>padding</strong> (<em>-</em>) – 处理边界时填充0的数量, 默认为0(不填充).</li>
<li><strong>dilation</strong> (<em>-</em>) – 采样间隔数量, 默认为1, 无间隔采样.</li>
<li><strong>groups</strong> (<em>-</em>) – 输入与输出通道的分组数量. 当不为1时, 默认为1(全连接).</li>
<li><strong>bias</strong> (<em>-</em>) – 为 <code>True</code> 时, 添加偏置.</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入 Input: <code>\((N, C_{in}, L_{in})\)</code></li>
<li>输出 Output: <code>\((N, C_{out}, L_{out})\)</code> 其中 <code>\(L_{out} = floor((L_{in} + 2 * padding - dilation * (kernel\_size - 1) - 1) / stride + 1)\)</code></li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 卷积网络层间连接的权重, 是模型需要学习的变量, 形状为 (out_channels, in_channels, kernel_size)</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 偏置, 是模型需要学习的变量, 形状为 (out_channels)</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Conv1d(16, 33, 3, stride=2)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="conv2d">Conv2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)</code></pre>


<p>二维卷积层 输入矩阵的维度为 <code>\((N, C_{in}, H, W)\)</code> , 输出矩阵维度为 <code>\((N, C_{out}, H_{out}, W_{out})\)</code> . 其中N为输入数量, C为每个输入样本的通道数量, H, W 分别为样本中一个通道下的数据的形状. 算法如下:</p>
<pre class="codehilite"><code class="language-py">\[\begin{array}{ll} out(N_i, C_{out_j}) = bias(C_{out_j}) + \sum_{{k}=0}^{C_{in}-1} weight(C_{out_j}, k) \star input(N_i, k) \end{array}\]</code></pre>


<p><code>\(\star\)</code> 是互相关运算符, 上式带:math:[<code>](#id3)star</code>项为卷积项.</p>
<p><code>stride</code> 计算相关系数的步长, 可以为 tuple .<code>padding</code> 处理边界时在每个维度首尾补0数量.<code>dilation</code> 采样间隔数量. 大于1时为非致密采样.<code>groups</code> 控制输入和输出之间的连接, group=1, 输出是所有输入的卷积； group=2, 此时</p>
<p>相当于有并排的两个卷基层, 每个卷积层只在对应的输入通道和输出通道之间计算, 并且输出时会将所有 输出通道简单的首尾相接作为结果输出.</p>
<blockquote>
<p>&lt;cite&gt;in_channels&lt;/cite&gt; 和 [<code>](#id5)out_channels</code>都要可以被 groups 整除.</p>
</blockquote>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 可以为:</p>
<blockquote>
<ul>
<li>单个 <code>int</code> 值 – 宽和高均被设定为此值.</li>
<li>由两个 <code>int</code> 组成的 <code>tuple</code> – 第一个 <code>int</code> 为高, 第二个 <code>int</code> 为宽.</li>
</ul>
</blockquote>
<p>Note</p>
<p>数据的最后一列可能会因为 kernal 大小设定不当而被丢弃（大部分发生在 kernal 大小不能被输入 整除的时候, 适当的 padding 可以避免这个问题）.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>in_channels</strong> (<em>-</em>) – 输入信号的通道数.</li>
<li><strong>out_channels</strong> (<em>-</em>) – 卷积后输出结果的通道数.</li>
<li><strong>kernel_size</strong> (<em>-</em>) – 卷积核的形状.</li>
<li><strong>stride</strong> (<em>-</em>) – 卷积每次移动的步长, 默认为1.</li>
<li><strong>padding</strong> (<em>-</em>) – 处理边界时填充0的数量, 默认为0(不填充).</li>
<li><strong>dilation</strong> (<em>-</em>) – 采样间隔数量, 默认为1, 无间隔采样.</li>
<li><strong>groups</strong> (<em>-</em>) – 输入与输出通道的分组数量. 当不为1时, 默认为1(全连接).</li>
<li><strong>bias</strong> (<em>-</em>) – 为 <code>True</code> 时, 添加偏置.</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入 Input: <code>\((N, C_{in}, H_{in}, W_{in})\)</code></li>
<li>输出 Output: <code>\((N, C_{out}, H_{out}, W_{out})\)</code> 其中 <code>\(H_{out} = floor((H_{in} + 2 * padding[0] - dilation[0] * (kernel\_size[0] - 1) - 1) / stride[0] + 1)\)</code> <code>\(W_{out} = floor((W_{in} + 2 * padding[1] - dilation[1] * (kernel\_size[1] - 1) - 1) / stride[1] + 1)\)</code></li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 卷积网络层间连接的权重, 是模型需要学习的变量, 形状为 (out_channels, in_channels, kernel_size[0], kernel_size[1])</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 偏置, 是模型需要学习的变量, 形状为 (out_channels)</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.Conv2d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding and dilation
&gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50, 100))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="conv3d">Conv3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Conv3d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)</code></pre>


<p>三维卷基层 输入矩阵的维度为 <code>\((N, C_{in}, D, H, W)\)</code>, 输出矩阵维度为:<code>\((N, C_{out}, D_{out}, H_{out}, W_{out})\)</code>. 其中N为输入数量, C为每个输入样本的通道数量, D, H, W 分别为样本中一个通道下的数据的形状. 算法如下:</p>
<pre class="codehilite"><code class="language-py">\[\begin{array}{ll} out(N_i, C_{out_j}) = bias(C_{out_j}) + \sum_{{k}=0}^{C_{in}-1} weight(C_{out_j}, k) \star input(N_i, k) \end{array}\]</code></pre>


<p><code>\(\star\)</code> 是互相关运算符, 上式带:math:[<code>](#id9)star</code>项为卷积项.</p>
<p><code>stride</code> 计算相关系数的步长, 可以为 tuple .<code>padding</code> 处理边界时在每个维度首尾补0数量.<code>dilation</code> 采样间隔数量. 大于1时为非致密采样.<code>groups</code> 控制输入和输出之间的连接, group=1, 输出是所有输入的卷积； group=2, 此时</p>
<p>相当于有并排的两个卷基层, 每个卷积层只在对应的输入通道和输出通道之间计算, 并且输出时会将所有 输出通道简单的首尾相接作为结果输出.</p>
<blockquote>
<p>&lt;cite&gt;in_channels&lt;/cite&gt; 和 [<code>](#id11)out_channels</code>都要可以被 groups 整除.</p>
</blockquote>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 可以为:</p>
<blockquote>
<ul>
<li>单个 <code>int</code> 值 – 宽和高和深度均被设定为此值.</li>
<li>由三个 <code>int</code> 组成的 <code>tuple</code> – 第一个 <code>int</code> 为深度, 第二个 <code>int</code> 为高度, 第三个 <code>int</code> 为宽度.</li>
</ul>
</blockquote>
<p>Note</p>
<p>数据的最后一列可能会因为 kernal 大小设定不当而被丢弃（大部分发生在 kernal 大小不能被输入 整除的时候, 适当的 padding 可以避免这个问题）.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>in_channels</strong> (<em>-</em>) – 输入信号的通道数.</li>
<li><strong>out_channels</strong> (<em>-</em>) – 卷积后输出结果的通道数.</li>
<li><strong>kernel_size</strong> (<em>-</em>) – 卷积核的形状.</li>
<li><strong>stride</strong> (<em>-</em>) – 卷积每次移动的步长, 默认为1.</li>
<li><strong>padding</strong> (<em>-</em>) – 处理边界时填充0的数量, 默认为0(不填充).</li>
<li><strong>dilation</strong> (<em>-</em>) – 采样间隔数量, 默认为1, 无间隔采样.</li>
<li><strong>groups</strong> (<em>-</em>) – 输入与输出通道的分组数量. 当不为1时, 默认为1(全连接).</li>
<li><strong>bias</strong> (<em>-</em>) – 为 <code>True</code> 时, 添加偏置.</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入 Input: <code>\((N, C_{in}, D_{in}, H_{in}, W_{in})\)</code></li>
<li>输出 Output: <code>\((N, C_{out}, D_{out}, H_{out}, W_{out})\)</code> 其中 <code>\(D_{out} = floor((D_{in} + 2 * padding[0] - dilation[0] * (kernel\_size[0] - 1) - 1) / stride[0] + 1)\)</code> <code>\(H_{out} = floor((H_{in} + 2 * padding[1] - dilation[1] * (kernel\_size[1] - 1) - 1) / stride[1] + 1)\)</code> <code>\(W_{out} = floor((W_{in} + 2 * padding[2] - dilation[2] * (kernel\_size[2] - 1) - 1) / stride[2] + 1)\)</code></li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 卷积网络层间连接的权重, 是模型需要学习的变量, 形状为 (out_channels, in_channels, kernel_size[0], kernel_size[1], kernel_size[2])</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 偏置, 是模型需要学习的变量, 形状为 (out_channels)</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.Conv3d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.Conv3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(4, 2, 0))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 10, 50, 100))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="convtranspose1d">ConvTranspose1d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ConvTranspose1d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1)</code></pre>


<p>一维反卷积层 反卷积层可以理解为输入的数据和卷积核的位置反转的卷积操作. 反卷积有时候也会被翻译成解卷积.</p>
<p><code>stride</code> 计算相关系数的步长.<code>padding</code> 处理边界时在每个维度首尾补0数量.<code>output_padding</code> 输出时候在首尾补0的数量. （卷积时, 形状不同的输入数据</p>
<p>对相同的核函数可以产生形状相同的结果；反卷积时, 同一个输入对相同的核函数可以产生多 个形状不同的输出, 而输出结果只能有一个, 因此必须对输出形状进行约束）. | <code>dilation</code> 采样间隔数量. 大于1时为非致密采样. | <code>groups</code> 控制输入和输出之间的连接, group=1, 输出是所有输入的卷积； group=2, 此时 相当于有并排的两个卷基层, 每个卷积层只在对应的输入通道和输出通道之间计算, 并且输出时会将所有 输出通道简单的首尾相接作为结果输出.</p>
<blockquote>
<p>&lt;cite&gt;in_channels&lt;/cite&gt; 和 [<code>](#id15)out_channels</code>都要可以被 groups 整除.</p>
</blockquote>
<p>Note</p>
<p>数据的最后一列可能会因为 kernal 大小设定不当而被丢弃（大部分发生在 kernal 大小不能被输入 整除的时候, 适当的 padding 可以避免这个问题）.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>in_channels</strong> (<em>-</em>) – 输入信号的通道数.</li>
<li><strong>out_channels</strong> (<em>-</em>) – 卷积后输出结果的通道数.</li>
<li><strong>kernel_size</strong> (<em>-</em>) – 卷积核的形状.</li>
<li><strong>stride</strong> (<em>-</em>) – 卷积每次移动的步长, 默认为1.</li>
<li><strong>padding</strong> (<em>-</em>) – 处理边界时填充0的数量, 默认为0(不填充).</li>
<li><strong>output_padding</strong> (<em>-</em>) – 输出时候在首尾补值的数量, 默认为0. （卷积时, 形状不同的输入数据</li>
<li><strong>同一个输入对相同的核函数可以产生多</strong> (<em>对相同的核函数可以产生形状相同的结果；反卷积时__,</em>) –</li>
<li><strong>而输出结果只能有一个, 因此必须对输出形状进行约束）</strong> (<em>个形状不同的输出__,</em>) –</li>
<li><strong>groups</strong> (<em>-</em>) – 输入与输出通道的分组数量. 当不为1时, 默认为1(全连接).</li>
<li><strong>bias</strong> (<em>-</em>) – 为 <code>True</code> 时, 添加偏置.</li>
<li><strong>dilation</strong> (<em>-</em>) – 采样间隔数量, 默认为1, 无间隔采样.</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入 Input: <code>\((N, C_{in}, L_{in})\)</code></li>
<li>输出 Output: <code>\((N, C_{out}, L_{out})\)</code> 其中 <code>\(L_{out} = (L_{in} - 1) * stride - 2 * padding + kernel\_size + output\_padding\)</code></li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 卷积网络层间连接的权重, 是模型需要学习的变量, 形状为weight (Tensor): 卷积网络层间连接的权重, 是模型需要学习的变量, 形状为 (in_channels, out_channels, kernel_size[0], kernel_size[1])</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 偏置, 是模型需要学习的变量, 形状为 (out_channels)</li>
</ul>
<p>|
| --- | --- |</p>
<h3 id="convtranspose2d">ConvTranspose2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1)</code></pre>


<p>二维反卷积层 反卷积层可以理解为输入的数据和卷积核的位置反转的卷积操作. 反卷积有时候也会被翻译成解卷积.</p>
<p><code>stride</code> 计算相关系数的步长.<code>padding</code> 处理边界时在每个维度首尾补0数量.<code>output_padding</code> 输出时候在每一个维度首尾补0的数量. （卷积时, 形状不同的输入数据</p>
<p>对相同的核函数可以产生形状相同的结果；反卷积时, 同一个输入对相同的核函数可以产生多 个形状不同的输出, 而输出结果只能有一个, 因此必须对输出形状进行约束）. | <code>dilation</code> 采样间隔数量. 大于1时为非致密采样. | <code>groups</code> 控制输入和输出之间的连接, group=1, 输出是所有输入的卷积； group=2, 此时 相当于有并排的两个卷基层, 每个卷积层只在对应的输入通道和输出通道之间计算, 并且输出时会将所有 输出通道简单的首尾相接作为结果输出.</p>
<blockquote>
<p>&lt;cite&gt;in_channels&lt;/cite&gt; 和 [<code>](#id17)out_channels</code>都应当可以被 groups 整除.</p>
</blockquote>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>output_padding</code> 可以为:</p>
<blockquote>
<ul>
<li>单个 <code>int</code> 值 – 宽和高均被设定为此值.</li>
<li>由两个 <code>int</code> 组成的 <code>tuple</code> – 第一个 <code>int</code> 为高度, 第二个 <code>int</code> 为宽度.</li>
</ul>
</blockquote>
<p>Note</p>
<p>数据的最后一列可能会因为 kernal 大小设定不当而被丢弃（大部分发生在 kernal 大小不能被输入 整除的时候, 适当的 padding 可以避免这个问题）.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>in_channels</strong> (<em>-</em>) – 输入信号的通道数.</li>
<li><strong>out_channels</strong> (<em>-</em>) – 卷积后输出结果的通道数.</li>
<li><strong>kernel_size</strong> (<em>-</em>) – 卷积核的形状.</li>
<li><strong>stride</strong> (<em>-</em>) – 卷积每次移动的步长, 默认为1.</li>
<li><strong>padding</strong> (<em>-</em>) – 处理边界时填充0的数量, 默认为0(不填充).</li>
<li><strong>output_padding</strong> (<em>-</em>) – 输出时候在首尾补值的数量, 默认为0. （卷积时, 形状不同的输入数据</li>
<li><strong>同一个输入对相同的核函数可以产生多</strong> (<em>对相同的核函数可以产生形状相同的结果；反卷积时__,</em>) –</li>
<li><strong>而输出结果只能有一个, 因此必须对输出形状进行约束）</strong> (<em>个形状不同的输出__,</em>) –</li>
<li><strong>groups</strong> (<em>-</em>) – 输入与输出通道的分组数量. 当不为1时, 默认为1(全连接).</li>
<li><strong>bias</strong> (<em>-</em>) – 为 <code>True</code> 时, 添加偏置.</li>
<li><strong>dilation</strong> (<em>-</em>) – 采样间隔数量, 默认为1, 无间隔采样.</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入 Input: <code>\((N, C_{in}, H_{in}, W_{in})\)</code></li>
<li>输出 Output: <code>\((N, C_{out}, H_{out}, W_{out})\)</code> 其中 <code>\(H_{out} = (H_{in} - 1) * stride[0] - 2 * padding[0] + kernel\_size[0] + output\_padding[0]\)</code> <code>\(W_{out} = (W_{in} - 1) * stride[1] - 2 * padding[1] + kernel\_size[1] + output\_padding[1]\)</code></li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 卷积网络层间连接的权重, 是模型需要学习的变量, 形状为weight (Tensor): 卷积网络层间连接的权重, 是模型需要学习的变量, 形状为 (in_channels, out_channels, kernel_size[0], kernel_size[1])</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 偏置, 是模型需要学习的变量, 形状为 (out_channels)</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.ConvTranspose2d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.ConvTranspose2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50, 100))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # exact output size can be also specified as an argument
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 16, 12, 12))
&gt;&gt;&gt; downsample = nn.Conv2d(16, 16, 3, stride=2, padding=1)
&gt;&gt;&gt; upsample = nn.ConvTranspose2d(16, 16, 3, stride=2, padding=1)
&gt;&gt;&gt; h = downsample(input)
&gt;&gt;&gt; h.size()
torch.Size([1, 16, 6, 6])
&gt;&gt;&gt; output = upsample(h, output_size=input.size())
&gt;&gt;&gt; output.size()
torch.Size([1, 16, 12, 12])</code></pre>


<h3 id="convtranspose3d">ConvTranspose3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ConvTranspose3d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1)</code></pre>


<p>三维反卷积层 反卷积层可以理解为输入的数据和卷积核的位置反转的卷积操作. 反卷积有时候也会被翻译成解卷积.</p>
<p><code>stride</code> 计算相关系数的步长.<code>padding</code> 处理边界时在每个维度首尾补0数量.<code>output_padding</code> 输出时候在每一个维度首尾补0的数量. （卷积时, 形状不同的输入数据</p>
<p>对相同的核函数可以产生形状相同的结果；反卷积时, 同一个输入对相同的核函数可以产生多 个形状不同的输出, 而输出结果只能有一个, 因此必须对输出形状进行约束） | <code>dilation</code> 采样间隔数量. 大于1时为非致密采样. | <code>groups</code> 控制输入和输出之间的连接, group=1, 输出是所有输入的卷积； group=2, 此时 相当于有并排的两个卷基层, 每个卷积层只在对应的输入通道和输出通道之间计算, 并且输出时会将所有 输出通道简单的首尾相接作为结果输出.</p>
<blockquote>
<p>&lt;cite&gt;in_channels&lt;/cite&gt; 和 [<code>](#id21)out_channels</code>都应当可以被 groups 整除.</p>
</blockquote>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>output_padding</code> 可以为:</p>
<blockquote>
<ul>
<li>单个 <code>int</code> 值 – 深和宽和高均被设定为此值.</li>
<li>由三个 <code>int</code> 组成的 <code>tuple</code> – 第一个 <code>int</code> 为深度, 第二个 <code>int</code> 为高度,第三个 <code>int</code> 为宽度.</li>
</ul>
</blockquote>
<p>Note</p>
<p>数据的最后一列可能会因为 kernal 大小设定不当而被丢弃（大部分发生在 kernal 大小不能被输入 整除的时候, 适当的 padding 可以避免这个问题）.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>in_channels</strong> (<em>-</em>) – 输入信号的通道数.</li>
<li><strong>out_channels</strong> (<em>-</em>) – 卷积后输出结果的通道数.</li>
<li><strong>kernel_size</strong> (<em>-</em>) – 卷积核的形状.</li>
<li><strong>stride</strong> (<em>-</em>) – 卷积每次移动的步长, 默认为1.</li>
<li><strong>padding</strong> (<em>-</em>) – 处理边界时填充0的数量, 默认为0(不填充).</li>
<li><strong>output_padding</strong> (<em>-</em>) – 输出时候在首尾补值的数量, 默认为0. （卷积时, 形状不同的输入数据</li>
<li><strong>同一个输入对相同的核函数可以产生多</strong> (<em>对相同的核函数可以产生形状相同的结果；反卷积时__,</em>) –</li>
<li><strong>而输出结果只能有一个, 因此必须对输出形状进行约束）</strong> (<em>个形状不同的输出__,</em>) –</li>
<li><strong>groups</strong> (<em>-</em>) – 输入与输出通道的分组数量. 当不为1时, 默认为1(全连接).</li>
<li><strong>bias</strong> (<em>-</em>) – 为 <code>True</code> 时, 添加偏置.</li>
<li><strong>dilation</strong> (<em>-</em>) – 采样间隔数量, 默认为1, 无间隔采样.</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入 Input: <code>\((N, C_{in}, D_{in}, H_{in}, W_{in})\)</code></li>
<li>输出 Output: <code>\((N, C_{out}, D_{out}, H_{out}, W_{out})\)</code> 其中 <code>\(D_{out} = (D_{in} - 1) * stride[0] - 2 * padding[0] + kernel\_size[0] + output\_padding[0]\)</code> <code>\(H_{out} = (H_{in} - 1) * stride[1] - 2 * padding[1] + kernel\_size[1] + output\_padding[1]\)</code> <code>\(W_{out} = (W_{in} - 1) * stride[2] - 2 * padding[2] + kernel\_size[2] + output\_padding[2]\)</code></li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>是模型需要学习的变量, 形状为weight</strong> (<em>卷积网络层间连接的权重__,</em>) – 卷积网络层间连接的权重, 是模型需要学习的变量, 形状为 (in_channels, out_channels, kernel_size[0], kernel_size[1], kernel_size[2])</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 偏置, 是模型需要学习的变量, 形状为 (out_channels)</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.ConvTranspose3d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.Conv3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(0, 4, 2))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 10, 50, 100))
&gt;&gt;&gt; output = m(input)</code></pre>


<h2 id="pooling-layers">Pooling Layers (池化层)</h2>
<h3 id="maxpool1d">MaxPool1d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MaxPool1d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)</code></pre>


<p>对于多个输入通道组成的输入信号,应用一维的最大池化 <code>max pooling</code> 操作</p>
<p>最简单的例子, 如果输入大小为 <code>\((N, C, L)\)</code>, 输出大小为 <code>\((N, C, L_{out})\)</code>, 该层输出值可以用下式精确计算:</p>
<pre class="codehilite"><code class="language-py">\[\begin{array}{ll} out(N_i, C_j, k) = \max_{{m}=0}^{{kernel\_size}-1} input(N_i, C_j, stride * k + m) \end{array}\]</code></pre>


<p>如果 <code>padding</code> 不是0,那么在输入数据的每条边上会隐式填补对应 <code>padding</code> 数量的0值点<code>dilation</code> 用于控制内核点之间的间隔, <a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a> 很好地可视化展示了 <code>dilation</code> 的功能</p>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作时的窗口大小</li>
<li><strong>stride</strong> – 最大池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 输入的每条边隐式补0的数量</li>
<li><strong>dilation</strong> – 用于控制窗口中元素的步长的参数</li>
<li><strong>return_indices</strong> – 如果等于 <code>True</code>, 在返回 max pooling 结果的同时返回最大值的索引. 这在之后的 Unpooling 时很有用</li>
<li><strong>ceil_mode</strong> – 如果等于 <code>True</code>, 在计算输出大小时,将采用向上取整来代替默认的向下取整的方式</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, L_{in})\)</code></li>
<li>Output: <code>\((N, C, L_{out})\)</code> 遵从如下关系 <code>\(L_{out} = floor((L_{in} + 2 * padding - dilation * (kernel\_size - 1) - 1) / stride + 1)\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # pool of size=3, stride=2
&gt;&gt;&gt; m = nn.MaxPool1d(3, stride=2)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="maxpool2d">MaxPool2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)</code></pre>


<p>对于多个输入通道组成的输入信号,应用二维的最大池化 <code>max pooling</code> 操作</p>
<p>最简单的例子, 如果输入大小为 <code>\((N, C, H, W)\)</code>, 输出大小为 <code>\((N, C, H_{out}, W_{out})\)</code>, 池化窗口大小 <code>kernel_size</code> 为 <code>\((kH, kW)\)</code> 该层输出值可以用下式精确计算:</p>
<pre class="codehilite"><code class="language-py">\[\begin{array}{ll} out(N_i, C_j, h, w) = \max_{{m}=0}^{kH-1} \max_{{n}=0}^{kW-1} input(N_i, C_j, stride[0] * h + m, stride[1] * w + n) \end{array}\]</code></pre>


<p>如果 <code>padding</code> 不是0, 那么在输入数据的每条边上会隐式填补对应 <code>padding</code> 数量的0值点<code>dilation</code> 用于控制内核点之间的间隔, <a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a> 很好地可视化展示了 <code>dilation</code> 的功能</p>
<p>参数 <code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 可以是以下任意一种数据类型:</p>
<blockquote>
<ul>
<li>单个 <code>int</code> 类型数据 – 此时在 height 和 width 维度上将使用相同的值</li>
<li>包含两个 int 类型数据的 <code>tuple</code> 元组 – 此时第一个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 height 维度上的数值, 第二个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 width 维度上的数值</li>
</ul>
</blockquote>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作时的窗口大小</li>
<li><strong>stride</strong> – 最大池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 输入的每条边隐式补0的数量</li>
<li><strong>dilation</strong> – 用于控制窗口中元素的步长的参数</li>
<li><strong>return_indices</strong> – 如果等于 <code>True</code>, 在返回 max pooling 结果的同时返回最大值的索引 这在之后的 Unpooling 时很有用</li>
<li><strong>ceil_mode</strong> – 如果等于 <code>True</code>, 在计算输出大小时,将采用向上取整来代替默认的向下取整的方式</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> 遵从如下关系 <code>\(H_{out} = floor((H_{in} + 2 * padding[0] - dilation[0] * (kernel\_size[0] - 1) - 1) / stride[0] + 1)\)</code> <code>\(W_{out} = floor((W_{in} + 2 * padding[1] - dilation[1] * (kernel\_size[1] - 1) - 1) / stride[1] + 1)\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.MaxPool2d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.MaxPool2d((3, 2), stride=(2, 1))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50, 32))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="maxpool3d">MaxPool3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MaxPool3d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)</code></pre>


<p>对于多个输入通道组成的输入信号,应用三维的最大池化 <code>max pooling</code> 操作</p>
<p>最简单的例子, 如果输入大小为 <code>\((N, C, D, H, W)\)</code>,输出大小为 <code>\((N, C, D_{out}, H_{out}, W_{out})\)</code> 池化窗口大小 <code>kernel_size</code> 为 <code>\((kD, kH, kW)\)</code> 该层输出值可以用下式精确计算:</p>
<pre class="codehilite"><code class="language-py">\[\begin{array}{ll} out(N_i, C_j, d, h, w) = \max_{{k}=0}^{kD-1} \max_{{m}=0}^{kH-1} \max_{{n}=0}^{kW-1} input(N_i, C_j, stride[0] * k + d, stride[1] * h + m, stride[2] * w + n) \end{array}\]</code></pre>


<p>如果 <code>padding</code> 不是0, 那么在输入数据的每条边上会隐式填补对应 <code>padding</code> 数量的0值点<code>dilation</code> 用于控制内核点之间的间隔, <a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a> 很好地可视化展示了 <code>dilation</code> 的功能</p>
<p>参数 <code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 可以是以下任意一种数据类型:</p>
<blockquote>
<ul>
<li>单个 <code>int</code> 类型数据 – 此时在 depth, height 和 width 维度上将使用相同的值</li>
<li>包含三个 int 类型数据的 <code>tuple</code> 元组 – 此时第一个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 depth 维度上的数值, 第二个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 height 维度上的数值,第三个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 width 维度上的数值</li>
</ul>
</blockquote>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作时的窗口大小</li>
<li><strong>stride</strong> – 最大池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 输入所有三条边上隐式补0的数量</li>
<li><strong>dilation</strong> – 用于控制窗口中元素的步长的参数</li>
<li><strong>return_indices</strong> – 如果等于 <code>True</code>, 在返回 max pooling 结果的同时返回最大值的索引 这在之后的 Unpooling 时很有用</li>
<li><strong>ceil_mode</strong> – 如果等于 <code>True</code>, 在计算输出大小时,将采用向上取整来代替默认的向下取整的方式</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, D_{in}, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, D_{out}, H_{out}, W_{out})\)</code> 遵从如下关系 <code>\(D_{out} = floor((D_{in} + 2 * padding[0] - dilation[0] * (kernel\_size[0] - 1) - 1) / stride[0] + 1)\)</code> <code>\(H_{out} = floor((H_{in} + 2 * padding[1] - dilation[1] * (kernel\_size[1] - 1) - 1) / stride[1] + 1)\)</code> <code>\(W_{out} = floor((W_{in} + 2 * padding[2] - dilation[2] * (kernel\_size[2] - 1) - 1) / stride[2] + 1)\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.MaxPool3d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.MaxPool3d((3, 2, 2), stride=(2, 1, 2))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50,44, 31))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="maxunpool1d">MaxUnpool1d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MaxUnpool1d(kernel_size, stride=None, padding=0)</code></pre>


<p><a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a> 的逆过程</p>
<p>要注意的是 <a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a> 并不是完全可逆的, 因为在max pooling过程中非最大值已经丢失</p>
<p><a href="#torch.nn.MaxUnpool1d" title="torch.nn.MaxUnpool1d"><code>MaxUnpool1d</code></a> 以 <a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a> 的输出, 包含最大值的索引作为输入 计算max poooling的部分逆过程(对于那些最大值区域), 对于那些非最大值区域将设置为0值</p>
<p>Note</p>
<p><cite>MaxPool1d</cite> 可以将多个输入大小映射到相同的输出大小, 因此反演过程可能会模棱两可 为适应这一点, 在调用forward函数时可以将需要的输出大小作为额外的参数 <cite>output_size</cite> 传入.</p>
<p>� 具体用法,请参阅下面的输入和示例</p>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 最大池化操作时的窗口大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 最大池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 输入的每条边填充0值的个数</li>
</ul>
<p>|
| --- | --- |</p>
<p>Inputs:</p>
<ul>
<li>&lt;cite&gt;input&lt;/cite&gt;: 需要转化的输入的 Tensor</li>
<li>&lt;cite&gt;indices&lt;/cite&gt;: &lt;cite&gt;MaxPool1d&lt;/cite&gt; 提供的最大值索引</li>
<li>&lt;cite&gt;output_size&lt;/cite&gt; (可选) : &lt;cite&gt;torch.Size&lt;/cite&gt; 类型的数据指定输出的大小</li>
</ul>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out})\)</code> 遵从如下关系 <code>\(H_{out} = (H_{in} - 1) * stride[0] - 2 * padding[0] + kernel\_size[0]\)</code> 或者在调用时指定输出大小 <code>output_size</code></li>
</ul>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; pool = nn.MaxPool1d(2, stride=2, return_indices=True)
&gt;&gt;&gt; unpool = nn.MaxUnpool1d(2, stride=2)
&gt;&gt;&gt; input = Variable(torch.Tensor([[[1, 2, 3, 4, 5, 6, 7, 8]]]))
&gt;&gt;&gt; output, indices = pool(input)
&gt;&gt;&gt; unpool(output, indices)
Variable containing:
(0 ,.,.) =
 0   2   0   4   0   6   0   8
[torch.FloatTensor of size 1x1x8]

&gt;&gt;&gt; # Example showcasing the use of output_size
&gt;&gt;&gt; input = Variable(torch.Tensor([[[1, 2, 3, 4, 5, 6, 7, 8, 9]]]))
&gt;&gt;&gt; output, indices = pool(input)
&gt;&gt;&gt; unpool(output, indices, output_size=input.size())
Variable containing:
(0 ,.,.) =
 0   2   0   4   0   6   0   8   0
[torch.FloatTensor of size 1x1x9]

&gt;&gt;&gt; unpool(output, indices)
Variable containing:
(0 ,.,.) =
 0   2   0   4   0   6   0   8
[torch.FloatTensor of size 1x1x8]</code></pre>


<h3 id="maxunpool2d">MaxUnpool2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MaxUnpool2d(kernel_size, stride=None, padding=0)</code></pre>


<p><a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a> 的逆过程</p>
<p>要注意的是 <a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a> 并不是完全可逆的, 因为在max pooling过程中非最大值已经丢失</p>
<p><a href="#torch.nn.MaxUnpool2d" title="torch.nn.MaxUnpool2d"><code>MaxUnpool2d</code></a> 以 <a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a> 的输出, 包含最大值的索引作为输入 计算max poooling的部分逆过程(对于那些最大值区域), 对于那些非最大值区域将设置为0值</p>
<p>Note</p>
<p><cite>MaxPool2d</cite> 可以将多个输入大小映射到相同的输出大小, 因此反演过程可能会模棱两可. 为适应这一点, 在调用forward函数时可以将需要的输出大小作为额外的参数 <cite>output_size</cite> 传入.</p>
<p>� 具体用法,请参阅下面的输入和示例</p>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 最大池化操作时的窗口大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 最大池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 输入的每条边填充0值的个数</li>
</ul>
<p>|
| --- | --- |</p>
<p>Inputs:</p>
<ul>
<li>&lt;cite&gt;input&lt;/cite&gt;: 需要转化的输入的 Tensor</li>
<li>&lt;cite&gt;indices&lt;/cite&gt;: &lt;cite&gt;MaxPool2d&lt;/cite&gt; 提供的最大值索引</li>
<li>&lt;cite&gt;output_size&lt;/cite&gt; (可选) : &lt;cite&gt;torch.Size&lt;/cite&gt; 类型的数据指定输出的大小</li>
</ul>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> 遵从如下关系 <code>\(H_{out} = (H_{in} - 1) * stride[0] -2 * padding[0] + kernel\_size[0]\)</code> <code>\(W_{out} = (W_{in} - 1) * stride[1] -2 * padding[1] + kernel\_size[1]\)</code> 或者在调用时指定输出大小 <code>output_size</code></li>
</ul>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; pool = nn.MaxPool2d(2, stride=2, return_indices=True)
&gt;&gt;&gt; unpool = nn.MaxUnpool2d(2, stride=2)
&gt;&gt;&gt; input = Variable(torch.Tensor([[[[ 1,  2,  3,  4],
...                                  [ 5,  6,  7,  8],
...                                  [ 9, 10, 11, 12],
...                                  [13, 14, 15, 16]]]]))
&gt;&gt;&gt; output, indices = pool(input)
&gt;&gt;&gt; unpool(output, indices)
Variable containing:
(0 ,0 ,.,.) =
 0   0   0   0
 0   6   0   8
 0   0   0   0
 0  14   0  16
[torch.FloatTensor of size 1x1x4x4]

&gt;&gt;&gt; # specify a different output size than input size
&gt;&gt;&gt; unpool(output, indices, output_size=torch.Size([1, 1, 5, 5]))
Variable containing:
(0 ,0 ,.,.) =
 0   0   0   0   0
 6   0   8   0   0
 0   0   0  14   0
 16   0   0   0   0
 0   0   0   0   0
[torch.FloatTensor of size 1x1x5x5]</code></pre>


<h3 id="maxunpool3d">MaxUnpool3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MaxUnpool3d(kernel_size, stride=None, padding=0)</code></pre>


<p><a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a> 的逆过程</p>
<p>要注意的是 <a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a> 并不是完全可逆的, 因为在max pooling过程中非最大值已经丢失 <a href="#torch.nn.MaxUnpool3d" title="torch.nn.MaxUnpool3d"><code>MaxUnpool3d</code></a> 以 <a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a> 的输出, 包含最大值的索引作为输入 计算max poooling的部分逆过程(对于那些最大值区域), 对于那些非最大值区域将设置为0值</p>
<p>Note</p>
<p><cite>MaxPool3d</cite> 可以将多个输入大小映射到相同的输出大小, 因此反演过程可能会模棱两可. 为适应这一点, 在调用forward函数时可以将需要的输出大小作为额外的参数 <cite>output_size</cite> 传入.</p>
<p>� 具体用法,请参阅下面的输入和示例</p>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 最大池化操作时的窗口大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 最大池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 输入的每条边填充0值的个数</li>
</ul>
<p>|
| --- | --- |</p>
<p>Inputs:</p>
<ul>
<li>&lt;cite&gt;input&lt;/cite&gt;: 需要转化的输入的 Tensor</li>
<li>&lt;cite&gt;indices&lt;/cite&gt;: &lt;cite&gt;MaxPool3d&lt;/cite&gt; 提供的最大值索引</li>
<li>&lt;cite&gt;output_size&lt;/cite&gt; (可选) : &lt;cite&gt;torch.Size&lt;/cite&gt; 类型的数据指定输出的大小</li>
</ul>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, D_{in}, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, D_{out}, H_{out}, W_{out})\)</code> 遵从如下关系 <code>\(D_{out} = (D_{in} - 1) * stride[0] - 2 * padding[0] + kernel\_size[0]\)</code> <code>\(H_{out} = (H_{in} - 1) * stride[1] - 2 * padding[1] + kernel\_size[1]\)</code> <code>\(W_{out} = (W_{in} - 1) * stride[2] - 2 * padding[2] + kernel\_size[2]\)</code> 或者在调用时指定输出大小 <code>output_size</code></li>
</ul>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; pool = nn.MaxPool3d(3, stride=2, return_indices=True)
&gt;&gt;&gt; unpool = nn.MaxUnpool3d(3, stride=2)
&gt;&gt;&gt; output, indices = pool(Variable(torch.randn(20, 16, 51, 33, 15)))
&gt;&gt;&gt; unpooled_output = unpool(output, indices)
&gt;&gt;&gt; unpooled_output.size()
torch.Size([20, 16, 51, 33, 15])</code></pre>


<h3 id="avgpool1d">AvgPool1d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AvgPool1d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)</code></pre>


<p>对于多个输入通道组成的输入信号,应用一维的平均池化 <code>average pooling</code> 操作</p>
<p>最简单的例子, 如果输入大小为 <code>\((N, C, L)\)</code>, 输出大小为 <code>\((N, C, L_{out})\)</code>, 池化窗口大小 <code>kernel_size</code> 为 <code>\(k\)</code> 该层输出值可以用下式精确计算:</p>
<pre class="codehilite"><code class="language-py">\[\begin{array}{ll} out(N_i, C_j, l) = 1 / k * \sum_{{m}=0}^{k} input(N_i, C_j, stride * l + m) \end{array}\]</code></pre>


<p>如果 <code>padding</code> 不是0, 那么在输入数据的每条边上会隐式填补对应 <code>padding</code> 数量的0值点</p>
<p>参数 <code>kernel_size</code>, <code>stride</code>, <code>padding</code> 可以为单个 <code>int</code> 类型的数据 或者是一个单元素的tuple元组</p>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> – 平均池化操作时取平均值的窗口的大小</li>
<li><strong>stride</strong> – 平均池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 输入的每条边隐式补0的数量</li>
<li><strong>ceil_mode</strong> – 如果等于 <code>True</code>, 在计算输出大小时,将采用向上取整来代替默认的向下取整的方式</li>
<li><strong>count_include_pad</strong> – 如果等于 <code>True</code>, 在计算平均池化的值时,将考虑 <code>padding</code> 填充的0</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, L_{in})\)</code></li>
<li>Output: <code>\((N, C, L_{out})\)</code> 遵从如下关系 <code>\(L_{out} = floor((L_{in} + 2 * padding - kernel\_size) / stride + 1)\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # pool with window of size=3, stride=2
&gt;&gt;&gt; m = nn.AvgPool1d(3, stride=2)
&gt;&gt;&gt; m(Variable(torch.Tensor([[[1,2,3,4,5,6,7]]])))
Variable containing:
(0 ,.,.) =
 2  4  6
[torch.FloatTensor of size 1x1x3]</code></pre>


<h3 id="avgpool2d">AvgPool2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AvgPool2d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)</code></pre>


<p>对于多个输入通道组成的输入信号,应用二维的平均池化 <code>average pooling</code> 操作</p>
<p>最简单的例子,如果输入大小为 <code>\((N, C, H, W)\)</code>,输出大小为 <code>\((N, C, H_{out}, W_{out})\)</code>, 池化窗口大小 <code>kernel_size</code> 为 <code>\((kH, kW)\)</code> 该层输出值可以用下式精确计算:</p>
<pre class="codehilite"><code class="language-py">\[\begin{array}{ll} out(N_i, C_j, h, w) = 1 / (kH * kW) * \sum_{{m}=0}^{kH-1} \sum_{{n}=0}^{kW-1} input(N_i, C_j, stride[0] * h + m, stride[1] * w + n) \end{array}\]</code></pre>


<p>如果 <code>padding</code> 不是0, 那么在输入数据的每条边上会隐式填补对应 <code>padding</code> 数量的0值点</p>
<p>参数 <code>kernel_size</code>, <code>stride</code>, <code>padding</code> 可以是以下任意一种数据类型:</p>
<blockquote>
<ul>
<li>单个 <code>int</code> 类型数据 – 此时在 height 和 width 维度上将使用相同的值</li>
<li>包含两个 int 类型数据的 <code>tuple</code> 元组 – 此时第一个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 height 维度上的数值, 第二个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 width 维度上的数值</li>
</ul>
</blockquote>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> – 平均池化操作时取平均值的窗口的大小</li>
<li><strong>stride</strong> – 平均池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 输入的每条边隐式补0的数量</li>
<li><strong>ceil_mode</strong> – 如果等于 <code>True</code>, 在计算输出大小时,将采用向上取整来代替默认的向下取整的方式</li>
<li><strong>count_include_pad</strong> – 如果等于 <code>True</code>, 在计算平均池化的值时,将考虑 <code>padding</code> 填充的0</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> 遵从如下关系 <code>\(H_{out} = floor((H_{in} + 2 * padding[0] - kernel\_size[0]) / stride[0] + 1)\)</code> <code>\(W_{out} = floor((W_{in} + 2 * padding[1] - kernel\_size[1]) / stride[1] + 1)\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.AvgPool2d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.AvgPool2d((3, 2), stride=(2, 1))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50, 32))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="avgpool3d">AvgPool3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AvgPool3d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)</code></pre>


<p>对于多个输入通道组成的输入信号,应用三维的平均池化 <code>average pooling</code> 操作</p>
<p>最简单的例子, 如果输入大小为 <code>\((N, C, D, H, W)\)</code>,输出大小为 <code>\((N, C, D_{out}, H_{out}, W_{out})\)</code> 池化窗口大小 <code>kernel_size</code> 为 <code>\((kD, kH, kW)\)</code> 该层输出值可以用下式精确计算:</p>
<pre class="codehilite"><code class="language-py">\[\begin{array}{ll} out(N_i, C_j, d, h, w) = 1 / (kD * kH * kW) * \sum_{{k}=0}^{kD-1} \sum_{{m}=0}^{kH-1} \sum_{{n}=0}^{kW-1} input(N_i, C_j, stride[0] * d + k, stride[1] * h + m, stride[2] * w + n) \end{array}\]</code></pre>


<p>如果 <code>padding</code> 不是0, 那么在输入数据的每条边上会隐式填补对应 <code>padding</code> 数量的0值点</p>
<p>参数 <code>kernel_size</code>, <code>stride</code> 可以是以下任意一种数据类型:</p>
<blockquote>
<ul>
<li>单个 <code>int</code> 类型数据 – 此时在 depth, height 和 width 维度上将使用相同的值</li>
<li>包含三个 int 类型数据的 <code>tuple</code> 元组 – 此时第一个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 depth 维度上的数值, 第二个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 height 维度上的数值,第三个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 width 维度上的数值</li>
</ul>
</blockquote>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> – 平均池化操作时取平均值的窗口的大小</li>
<li><strong>stride</strong> – 平均池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 输入的每条边隐式补0的数量</li>
<li><strong>ceil_mode</strong> – 如果等于 <code>True</code>, 在计算输出大小时,将采用向上取整来代替默认的向下取整的方式</li>
<li><strong>count_include_pad</strong> – 如果等于 <code>True</code>, 在计算平均池化的值时,将考虑 <code>padding</code> 填充的0</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, D_{in}, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, D_{out}, H_{out}, W_{out})\)</code> 遵从如下关系 <code>\(D_{out} = floor((D_{in} + 2 * padding[0] - kernel\_size[0]) / stride[0] + 1)\)</code> <code>\(H_{out} = floor((H_{in} + 2 * padding[1] - kernel\_size[1]) / stride[1] + 1)\)</code> <code>\(W_{out} = floor((W_{in} + 2 * padding[2] - kernel\_size[2]) / stride[2] + 1)\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.AvgPool3d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.AvgPool3d((3, 2, 2), stride=(2, 1, 2))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50,44, 31))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="fractionalmaxpool2d">FractionalMaxPool2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.FractionalMaxPool2d(kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)</code></pre>


<p>对于多个输入通道组成的输入信号,应用二维的分数最大池化 <code>fractional max pooling</code> 操作</p>
<p>分数最大池化 <code>Fractiona MaxPooling</code> 的具体细节描述,详见Ben Graham论文 <a href="http://arxiv.org/abs/1412.6071">Fractional MaxPooling</a></p>
<p>由目标输出大小确定随机步长,在 kH x kW 区域内进行最大池化的操作 输出特征的数量与输入通道的数量相同</p>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作时窗口的大小. 可以是单个数字 k (等价于 k x k 的正方形窗口) 或者是 一个元组 tuple (kh x kw)</li>
<li><strong>output_size</strong> – oH x oW 形式的输出图像的尺寸. 可以用 一个 tuple 元组 (oH, oW) 表示 oH x oW 的输出尺寸, 或者是单个的数字 oH 表示 oH x oH 的输出尺寸</li>
<li><strong>output_ratio</strong> – 如果想用输入图像的百分比来指定输出图像的大小,可选用该选项. 使用范围在 (0,1) 之间的一个值来指定.</li>
<li><strong>return_indices</strong> – 如果等于 <code>True</code>,在返回输出结果的同时返回最大值的索引,该索引对 nn.MaxUnpool2d 有用. 默认情况下该值等于 <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, and target output size 13x12
&gt;&gt;&gt; m = nn.FractionalMaxPool2d(3, output_size=(13, 12))
&gt;&gt;&gt; # pool of square window and target output size being half of input image size
&gt;&gt;&gt; m = nn.FractionalMaxPool2d(3, output_ratio=(0.5, 0.5))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50, 32))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="lppool2d">LPPool2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.LPPool2d(norm_type, kernel_size, stride=None, ceil_mode=False)</code></pre>


<p>对于多个输入通道组成的输入信号,应用二维的幂平均池化 <code>power-average pooling</code> 操作</p>
<p>在每个窗口内, 输出的计算方式: <code>\(f(X) = pow(sum(pow(X, p)), 1/p)\)</code></p>
<blockquote>
<ul>
<li>当 p 无穷大时,等价于最大池化 <code>Max Pooling</code> 操作</li>
<li>当 <code>p=1</code> 时, 等价于平均池化 <code>Average Pooling</code> 操作</li>
</ul>
</blockquote>
<p>参数 <code>kernel_size</code>, <code>stride</code> 可以是以下任意一种数据类型:</p>
<blockquote>
<ul>
<li>单个 <code>int</code> 类型数据 – 此时在height和width维度上将使用相同的值</li>
<li>包含两个 int 类型数据的 <code>tuple</code> 元组 – 此时第一个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 height 维度上的数值, 第二个 &lt;cite&gt;int&lt;/cite&gt; 数据表示 width 维度上的数值</li>
</ul>
</blockquote>
<p>| Parameters: | </p>
<ul>
<li><strong>kernel_size</strong> – 幂平均池化时窗口的大小</li>
<li><strong>stride</strong> – 幂平均池化操作时窗口移动的步长, 默认值是 <code>kernel_size</code></li>
<li><strong>ceil_mode</strong> – 如果等于 <code>True</code>, 在计算输出大小时,将采用向上取整来代替默认的向下取整的方式</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> 遵从如下关系 <code>\(H_{out} = floor((H_{in} + 2 * padding[0] - dilation[0] * (kernel\_size[0] - 1) - 1) / stride[0] + 1)\)</code> <code>\(W_{out} = floor((W_{in} + 2 * padding[1] - dilation[1] * (kernel\_size[1] - 1) - 1) / stride[1] + 1)\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # power-2 pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.LPPool2d(2, 3, stride=2)
&gt;&gt;&gt; # pool of non-square window of power 1.2
&gt;&gt;&gt; m = nn.LPPool2d(1.2, (3, 2), stride=(2, 1))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 50, 32))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="adaptivemaxpool1d">AdaptiveMaxPool1d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AdaptiveMaxPool1d(output_size, return_indices=False)</code></pre>


<p>对于多个输入通道组成的输入信号,应用一维的自适应最大池化 <code>adaptive max pooling</code> 操作</p>
<p>对于任意大小的输入,可以指定输出的尺寸为 H 输出特征的数量与输入通道的数量相同.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>output_size</strong> – 目标输出的尺寸 H</li>
<li><strong>return_indices</strong> – 如果等于 <code>True</code>,在返回输出结果的同时返回最大值的索引,该索引对 nn.MaxUnpool1d 有用. 默认情况下该值等于 <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # target output size of 5
&gt;&gt;&gt; m = nn.AdaptiveMaxPool1d(5)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 8))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="adaptivemaxpool2d">AdaptiveMaxPool2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AdaptiveMaxPool2d(output_size, return_indices=False)</code></pre>


<p>对于多个输入通道组成的输入信号,应用二维的自适应最大池化 <code>adaptive max pooling</code> 操作</p>
<p>对于任意大小的输入,可以指定输出的尺寸为 H x W 输出特征的数量与输入通道的数量相同.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>output_size</strong> – H x W 形式的输出图像的尺寸. 可以用 一个 tuple 元组 (H, W) 表示 H x W 的输出尺寸, 或者是单个的数字 H 表示 H x H 的输出尺寸</li>
<li><strong>return_indices</strong> – 如果等于 <code>True</code>,在返回输出结果的同时返回最大值的索引,该索引对 nn.MaxUnpool2d 有用. 默认情况下该值等于 <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # target output size of 5x7
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d((5,7))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 8, 9))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7 (square)
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d(7)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 10, 9))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="adaptivemaxpool3d">AdaptiveMaxPool3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AdaptiveMaxPool3d(output_size, return_indices=False)</code></pre>


<p>对于多个输入通道组成的输入信号,应用三维的自适应最大池化 <code>adaptive max pooling</code> 操作</p>
<p>对于任意大小的输入,可以指定输出的尺寸为 D x H x W 输出特征的数量与输入通道的数量相同.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>output_size</strong> – D x H x W 形式的输出图像的尺寸. 可以用 一个 tuple 元组 (D, H, W) 表示 D x H x W 的输出尺寸, 或者是单个的数字 D 表示 D x D x D 的输出尺寸</li>
<li><strong>return_indices</strong> – 如果等于 <code>True</code>,在返回输出结果的同时返回最大值的索引,该索引对 nn.MaxUnpool3d 有用. 默认情况下该值等于 <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # target output size of 5x7x9
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d((5,7,9))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 8, 9, 10))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7x7 (cube)
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d(7)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 10, 9, 8))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="adaptiveavgpool1d">AdaptiveAvgPool1d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AdaptiveAvgPool1d(output_size)</code></pre>


<p>对于多个输入通道组成的输入信号,应用一维的自适应平均池化 <code>adaptive average pooling</code> 操作</p>
<p>对于任意大小的输入,可以指定输出的尺寸为 H 输出特征的数量与输入通道的数量相同.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>output_size</strong> – 目标输出的尺寸 H</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # target output size of 5
&gt;&gt;&gt; m = nn.AdaptiveAvgPool1d(5)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 8))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="adaptiveavgpool2d">AdaptiveAvgPool2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AdaptiveAvgPool2d(output_size)</code></pre>


<p>对于多个输入通道组成的输入信号,应用二维的自适应平均池化 <code>adaptive average pooling</code> 操作</p>
<p>对于任意大小的输入,可以指定输出的尺寸为 H x W 输出特征的数量与输入通道的数量相同.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>output_size</strong> – H x W 形式的输出图像的尺寸. 可以用 一个 tuple 元组 (H, W) 表示 H x W 的输出尺寸, 或者是单个的数字 H 表示 H x H 的输出尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # target output size of 5x7
&gt;&gt;&gt; m = nn.AdaptiveAvgPool2d((5,7))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 8, 9))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7 (square)
&gt;&gt;&gt; m = nn.AdaptiveAvgPool2d(7)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 10, 9))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="adaptiveavgpool3d">AdaptiveAvgPool3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AdaptiveAvgPool3d(output_size)</code></pre>


<p>对于多个输入通道组成的输入信号,应用三维的自适应平均池化 <code>adaptive average pooling</code> 操作</p>
<p>对于任意大小的输入,可以指定输出的尺寸为 D x H x W 输出特征的数量与输入通道的数量相同.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>output_size</strong> – D x H x W 形式的输出图像的尺寸. 可以用 一个 tuple 元组 (D, H, W) 表示 D x H x W 的输出尺寸, 或者是单个的数字 D 表示 D x D x D 的输出尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # target output size of 5x7x9
&gt;&gt;&gt; m = nn.AdaptiveAvgPool3d((5,7,9))
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 8, 9, 10))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7x7 (cube)
&gt;&gt;&gt; m = nn.AdaptiveAvgPool3d(7)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(1, 64, 10, 9, 8))
&gt;&gt;&gt; output = m(input)</code></pre>


<h2 id="padding-layers">Padding Layers (填充层)</h2>
<h3 id="reflectionpad2d">ReflectionPad2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ReflectionPad2d(padding)</code></pre>


<p>使用输入边界的反射填充输入张量.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 填充的大小. 如果是int, 则在所有边界填充使用相同的.</li>
<li><strong>则使用</strong> (<em>如果是4个元组__,</em>) –</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> where <code>\(H_{out} = H_{in} + paddingTop + paddingBottom\)</code> <code>\(W_{out} = W_{in} + paddingLeft + paddingRight\)</code></li>
</ul>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.ReflectionPad2d(3)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(16, 3, 320, 480))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # 使用不同的填充
&gt;&gt;&gt; m = nn.ReflectionPad2d((3, 3, 6, 6))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="replicationpad2d">ReplicationPad2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ReplicationPad2d(padding)</code></pre>


<p>使用输入边界的复制填充输入张量.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 填充的大小. 如果是int, 则在所有边界使用相同的填充. 如果是4个元组, 则使用(paddingLeft, paddingRight, paddingTop, paddingBottom)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> where <code>\(H_{out} = H_{in} + paddingTop + paddingBottom\)</code> <code>\(W_{out} = W_{in} + paddingLeft + paddingRight\)</code></li>
</ul>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.ReplicationPad2d(3)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(16, 3, 320, 480))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # 使用不同的填充
&gt;&gt;&gt; m = nn.ReplicationPad2d((3, 3, 6, 6))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="replicationpad3d">ReplicationPad3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ReplicationPad3d(padding)</code></pre>


<p>使用输入边界的复制填充输入张量.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 填充的大小. 如果是int, 则在所有边界使用相同的填充.</li>
<li><strong>则使用 (paddingLeft, paddingRight,</strong> (<em>如果是四个元组__,</em>) –</li>
<li><strong>paddingBottom, paddingFront, paddingBack)</strong> (<em>paddingTop__,</em>) –</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, D_{in}, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, D_{out}, H_{out}, W_{out})\)</code> where <code>\(D_{out} = D_{in} + paddingFront + paddingBack\)</code> <code>\(H_{out} = H_{in} + paddingTop + paddingBottom\)</code> <code>\(W_{out} = W_{in} + paddingLeft + paddingRight\)</code></li>
</ul>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.ReplicationPad3d(3)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(16, 3, 8, 320, 480))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # 使用不同的填充
&gt;&gt;&gt; m = nn.ReplicationPad3d((3, 3, 6, 6, 1, 1))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="zeropad2d">ZeroPad2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ZeroPad2d(padding)</code></pre>


<p>用零填充输入张量边界.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 填充的大小. 如果是int, 则在所有边界使用相同的填充.</li>
<li><strong>如果是四个元组, 则使用</strong> () –</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> where <code>\(H_{out} = H_{in} + paddingTop + paddingBottom\)</code> <code>\(W_{out} = W_{in} + paddingLeft + paddingRight\)</code></li>
</ul>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.ZeroPad2d(3)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(16, 3, 320, 480))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # 使用不同的填充
&gt;&gt;&gt; m = nn.ZeroPad2d((3, 3, 6, 6))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="constantpad2d">ConstantPad2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ConstantPad2d(padding, value)</code></pre>


<p>用一个常数值填充输入张量边界.</p>
<p>对于 Nd-padding, 使用 nn.functional.pad().</p>
<p>| Parameters: | </p>
<ul>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a>) – 填充的大小. 如果是int, 则在所有边界使用相同的填充.</li>
<li><strong>使用</strong> (<em>如果是4个元组__,</em>) –</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> where <code>\(H_{out} = H_{in} + paddingTop + paddingBottom\)</code> <code>\(W_{out} = W_{in} + paddingLeft + paddingRight\)</code></li>
</ul>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.ConstantPad2d(3, 3.5)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(16, 3, 320, 480))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # 使用不同的填充
&gt;&gt;&gt; m = nn.ConstantPad2d((3, 3, 6, 6), 3.5)
&gt;&gt;&gt; output = m(input)</code></pre>


<h2 id="non-linear-activations">Non-linear Activations (非线性层)</h2>
<h3 id="relu">ReLU</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ReLU(inplace=False)</code></pre>


<p>对输入运用修正线性单元函数 <code>\({ReLU}(x)= max(0, x)\)</code></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>inplace</strong> – 选择是否进行覆盖运算 Default: <code>False</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> &lt;cite&gt;*&lt;/cite&gt; 代表任意数目附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 与输入拥有同样的 shape 属性</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.ReLU()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="relu6">ReLU6</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ReLU6(inplace=False)</code></pre>


<p>对输入的每一个元素运用函数 <code>\({ReLU6}(x) = min(max(0,x), 6)\)</code></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>inplace</strong> – 选择是否进行覆盖运算 默认值: <code>False</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code>, &lt;cite&gt;*&lt;/cite&gt; 代表任意数目附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 与输入拥有同样的 shape 属性</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.ReLU6()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="elu">ELU</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.ELU(alpha=1.0, inplace=False)</code></pre>


<p>对输入的每一个元素运用函数, <code>\(f(x) = max(0,x) + min(0, alpha * (exp(x) - 1))\)</code></p>
<p>| Parameters: | </p>
<ul>
<li><strong>alpha</strong> – ELU 定义公式中的 alpha 值. 默认值: 1.0</li>
<li><strong>inplace</strong> – 选择是否进行覆盖运算 默认值: <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> &lt;cite&gt;*&lt;/cite&gt; 代表任意数目附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 与输入拥有同样的 shape 属性</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.ELU()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="selu">SELU</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.SELU(inplace=False)</code></pre>


<p>对输入的每一个元素运用函数, <code>\(f(x) = scale * (\max(0,x) + \min(0, alpha * (\exp(x) - 1)))\)</code>, <code>alpha=1.6732632423543772848170429916717</code>, <code>scale=1.0507009873554804934193349852946</code>.</p>
<p>更多地细节可以参阅论文 <a href="https://arxiv.org/abs/1706.02515">Self-Normalizing Neural Networks</a> .</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>inplace</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 选择是否进行覆盖运算. 默认值: <code>False</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> where &lt;cite&gt;*&lt;/cite&gt; means, any number of additional dimensions</li>
<li>Output: <code>\((N, *)\)</code>, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.SELU()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="prelu">PReLU</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.PReLU(num_parameters=1, init=0.25)</code></pre>


<p>对输入的每一个元素运用函数 <code>\(PReLU(x) = max(0,x) + a * min(0,x)\)</code> 这里的 “a” 是自学习的参数. 当不带参数地调用时, nn.PReLU() 在所有输入通道中使用单个参数 “a” . 而如果用 nn.PReLU(nChannels) 调用, “a” 将应用到每个输入.</p>
<p>Note</p>
<p>当为了表现更佳的模型而学习参数 “a” 时不要使用权重衰减 (weight decay)</p>
<p>| Parameters: | </p>
<ul>
<li><strong>num_parameters</strong> – 需要学习的 “a” 的个数. 默认等于1</li>
<li><strong>init</strong> – “a” 的初始值. 默认等于0.25</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> 其中 &lt;cite&gt;*&lt;/cite&gt; 代表任意数目的附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 和输入的格式 shape 一致</li>
</ul>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.PReLU()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="leakyrelu">LeakyReLU</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.LeakyReLU(negative_slope=0.01, inplace=False)</code></pre>


<p>对输入的每一个元素运用, <code>\(f(x) = max(0, x) + {negative\_slope} * min(0, x)\)</code></p>
<p>| Parameters: | </p>
<ul>
<li><strong>negative_slope</strong> – 控制负斜率的角度, 默认值: 1e-2</li>
<li><strong>inplace</strong> – 选择是否进行覆盖运算 默认值: <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> 其中 &lt;cite&gt;*&lt;/cite&gt; 代表任意数目的附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 和输入的格式shape一致</li>
</ul>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.LeakyReLU(0.1)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="threshold">Threshold</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Threshold(threshold, value, inplace=False)</code></pre>


<p>基于 Tensor 中的每个元素创造阈值函数</p>
<p>Threshold 被定义为</p>
<pre class="codehilite"><code class="language-py">y =  x        if x &gt;  threshold
     value    if x &lt;= threshold</code></pre>


<p>| Parameters: | </p>
<ul>
<li><strong>threshold</strong> – 阈值</li>
<li><strong>value</strong> – 输入值小于阈值则会被 value 代替</li>
<li><strong>inplace</strong> – 选择是否进行覆盖运算. 默认值: <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> 其中 &lt;cite&gt;*&lt;/cite&gt; 代表任意数目的附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 和输入的格式 shape 一致</li>
</ul>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Threshold(0.1, 20)
&gt;&gt;&gt; input = Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="hardtanh">Hardtanh</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Hardtanh(min_val=-1, max_val=1, inplace=False, min_value=None, max_value=None)</code></pre>


<p>对输入的每一个元素运用 HardTanh</p>
<p>HardTanh 被定义为:</p>
<pre class="codehilite"><code class="language-py">f(x) = +1, if x  &gt;  1
f(x) = -1, if x  &lt; -1
f(x) =  x,  otherwise</code></pre>


<p>线性区域的范围 <code>\([-1, 1]\)</code> 可以被调整</p>
<p>| Parameters: | </p>
<ul>
<li><strong>min_val</strong> – 线性区域范围最小值. 默认值: -1</li>
<li><strong>max_val</strong> – 线性区域范围最大值. 默认值: 1</li>
<li><strong>inplace</strong> – 选择是否进行覆盖运算. 默认值: <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>关键字参数 <code>min_value</code> 以及 <code>max_value</code> 已被弃用. 更改为 <code>min_val</code> 和 <code>max_val</code></p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> 其中 &lt;cite&gt;*&lt;/cite&gt; 代表任意维度组合</li>
<li>Output: <code>\((N, *)\)</code>, 与输入有相同的 shape 属性</li>
</ul>
<p>例</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Hardtanh(-2, 2)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="sigmoid">Sigmoid</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Sigmoid</code></pre>


<p>对每个元素运用 Sigmoid 函数. Sigmoid 定义如下 <code>\(f(x) = 1 / ( 1 + exp(-x))\)</code></p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> &lt;cite&gt;*&lt;/cite&gt; 表示任意维度组合</li>
<li>Output: <code>\((N, *)\)</code>, 与输入有相同的 shape 属性</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Sigmoid()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="tanh">Tanh</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Tanh</code></pre>


<p>对输入的每个元素, <code>\(f(x) = (exp(x) - exp(-x)) / (exp(x) + exp(-x))\)</code></p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> &lt;cite&gt;*&lt;/cite&gt; 表示任意维度组合</li>
<li>Output: <code>\((N, *)\)</code>, 与输入有相同的 shape 属性</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Tanh()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="logsigmoid">LogSigmoid</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.LogSigmoid</code></pre>


<p>对输入的每一个元素运用函数 <code>\(LogSigmoid(x) = log( 1 / (1 + exp(-x_i)))\)</code></p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> 其中 &lt;cite&gt;*&lt;/cite&gt; 代表任意数目的附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 和输入的格式shape一致</li>
</ul>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.LogSigmoid()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="softplus">Softplus</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Softplus(beta=1, threshold=20)</code></pre>


<p>对每个元素运用Softplus函数, Softplus 定义如下 :: <code>\(f(x) = 1/beta * log(1 + exp(beta * x_i))\)</code></p>
<p>Softplus 函数是ReLU函数的平滑逼近. Softplus 函数可以使得输出值限定为正数.</p>
<p>为了保证数值稳定性. 线性函数的转换可以使输出大于某个值.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>beta</strong> – Softplus 公式中的 beta 值. 默认值: 1</li>
<li><strong>threshold</strong> – 阈值. 当输入到该值以上时我们的SoftPlus实现将还原为线性函数. 默认值: 20</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> 其中 &lt;cite&gt;*&lt;/cite&gt; 代表任意数目的附加维度 dimensions</li>
<li>Output: <code>\((N, *)\)</code>, 和输入的格式shape一致</li>
</ul>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Softplus()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="softshrink">Softshrink</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Softshrink(lambd=0.5)</code></pre>


<p>对输入的每一个元素运用 soft shrinkage 函数</p>
<p>SoftShrinkage 运算符定义为:</p>
<pre class="codehilite"><code class="language-py">f(x) = x-lambda, if x &gt; lambda &gt;  f(x) = x+lambda, if x &lt; -lambda
f(x) = 0, otherwise</code></pre>


<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>lambd</strong> – Softshrink 公式中的 lambda 值. 默认值: 0.5</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> 其中 &lt;cite&gt;*&lt;/cite&gt; 代表任意数目的附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 和输入的格式 shape 一致</li>
</ul>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Softshrink()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="softsign">Softsign</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Softsign</code></pre>


<p>对输入的每一个元素运用函数 <code>\(f(x) = x / (1 + |x|)\)</code></p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> 其中 &lt;cite&gt;*&lt;/cite&gt; 代表任意数目的附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 和输入的格式 shape 一致</li>
</ul>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Softsign()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="tanhshrink">Tanhshrink</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Tanhshrink</code></pre>


<p>对输入的每一个元素运用函数, <code>\(Tanhshrink(x) = x - Tanh(x)\)</code></p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *)\)</code> 其中 &lt;cite&gt;*&lt;/cite&gt; 代表任意数目的附加维度</li>
<li>Output: <code>\((N, *)\)</code>, 和输入的格式shape一致</li>
</ul>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Tanhshrink()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="softmin">Softmin</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Softmin(dim=None)</code></pre>


<p>对n维输入张量运用 Softmin 函数, 将张量的每个元素缩放到 (0,1) 区间且和为 1.</p>
<p><code>\(f(x) = \frac{\exp(-x_i)}{\sum_j \exp(-x_j)}\)</code></p>
<p>Shape:</p>
<ul>
<li>Input: 任意shape</li>
<li>Output: 和输入相同</li>
</ul>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – 这是将计算 Softmax 的维度 (所以每个沿着 dim 的切片和为 1).</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>返回结果是一个与输入维度相同的张量, 每个元素的取值范围在 [0, 1] 区间.</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Softmin()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2, 3))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="softmax">Softmax</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Softmax(dim=None)</code></pre>


<p>对n维输入张量运用 Softmax 函数, 将张量的每个元素缩放到 (0,1) 区间且和为 1. Softmax 函数定义如下 <code>\(f_i(x) = \frac{\exp(x_i)}{\sum_j \exp(x_j)}\)</code></p>
<p>Shape:</p>
<ul>
<li>Input: 任意shape</li>
<li>Output: 和输入相同</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>返回结果是一个与输入维度相同的张量, 每个元素的取值范围在 [0, 1] 区间.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters:</td>
<td><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – 这是将计算 Softmax 的那个维度 (所以每个沿着 dim 的切片和为 1).</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>如果你想对原始 Softmax 数据计算 Log 进行收缩, 并不能使该模块直接使用 NLLLoss 负对数似然损失函数. 取而代之, 应该使用 Logsoftmax (它有更快的运算速度和更好的数值性质).</p>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Softmax()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2, 3))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="softmax2d">Softmax2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Softmax2d</code></pre>


<p>把 SoftMax 应用于每个空间位置的特征.</p>
<p>给定图片的 通道数 Channels x 高 Height x 宽 Width, 它将对图片的每一个位置 使用 Softmax <code>\((Channels, h_i, w_j)\)</code></p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H, W)\)</code></li>
<li>Output: <code>\((N, C, H, W)\)</code> (格式 shape 与输入相同)</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>一个维度及格式 shape 都和输入相同的 Tensor, 取值范围在[0, 1]</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Softmax2d()
&gt;&gt;&gt; # you softmax over the 2nd dimension
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2, 3, 12, 13))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h3 id="logsoftmax">LogSoftmax</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.LogSoftmax(dim=None)</code></pre>


<p>对每个输入的 n 维 Tensor 使用 Log(Softmax(x)). LogSoftmax 公式可简化为</p>
<p><code>\(f_i(x) = log(exp(x_i) / sum_j exp(x_j) )\)</code></p>
<p>Shape:</p>
<ul>
<li>Input: 任意格式 shape</li>
<li>Output: 和输入的格式 shape 一致</li>
</ul>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – 这是将计算 Softmax 的那个维度 (所以每个沿着 dim 的切片和为1).</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>一个维度及格式 shape 都和输入相同的 Tensor, 取值范围在 [-inf, 0)</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.LogSoftmax()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(2, 3))
&gt;&gt;&gt; print(input)
&gt;&gt;&gt; print(m(input))</code></pre>


<h2 id="normalization-layers">Normalization layers (归一化层)</h2>
<h3 id="batchnorm1d">BatchNorm1d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True)</code></pre>


<p>对 2d 或者 3d 的小批量 (mini-batch) 数据进行批标准化 (Batch Normalization) 操作.</p>
<pre class="codehilite"><code class="language-py">\[y = \frac{x - mean[x]}{ \sqrt{Var[x] + \epsilon}} * gamma + beta\]</code></pre>


<p>每个小批量数据中,计算各个维度的均值和标准差,并且 gamma 和 beta 是大小为 C 的可学习, 可改变的仿射参数向量( C 为输入大小).</p>
<p>在训练过程中,该层计算均值和方差,并进行平均移动,默认的平均移动动量值为 0.1.</p>
<p>在验证时,训练得到的均值/方差,用于标准化验证数据.</p>
<p>BatchNorm 在 ‘C’ 维上处理,即 ‘(N,L)’ 部分运行,被称作 ‘Temporal BatchNorm’</p>
<p>| Parameters: | </p>
<ul>
<li><strong>num_features</strong> – 预期输入的特征数,大小为 ‘batch_size x num_features [x width]’</li>
<li><strong>eps</strong> – 给分母加上的值,保证数值稳定(分母不能趋近0或取0),默认为 1e-5</li>
<li><strong>momentum</strong> – 动态均值和动态方差使用的移动动量值,默认为 0.1</li>
<li><strong>affine</strong> – 布尔值,设为 True 时,表示该层添加可学习,可改变的仿射参数,即 gamma 和 beta,默认为 True</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C)\)</code> or <code>\((N, C, L)\)</code></li>
<li>Output: <code>\((N, C)\)</code> or <code>\((N, C, L)\)</code> (same shape as input)</li>
</ul>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm1d(100)
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm1d(100, affine=False)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 100))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="batchnorm2d">BatchNorm2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True)</code></pre>


<p>对小批量 (mini-batch) 3d 数据组成的 4d 输入进行标准化 (Batch Normalization) 操作.</p>
<pre class="codehilite"><code class="language-py">\[y = \frac{x - mean[x]}{ \sqrt{Var[x] + \epsilon}} * gamma + beta\]</code></pre>


<p>每个小批量数据中,计算各个维度的均值和标准差, 并且 gamma 和 beta 是大小为 C 的可学习,可改变的仿射参数向量 (C 为输入大小).</p>
<p>在训练过程中,该层计算均值和方差,并进行平均移动.默认的平均移动动量值为 0.1.</p>
<p>在验证时,训练得到的均值/方差,用于标准化验证数据.</p>
<p>BatchNorm 在 ‘C’ 维上处理,即 ‘(N, H, W)’ 部分运行,被称作 ‘Spatial BatchNorm’.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>num_features</strong> – 预期输入的特征数,大小为 ‘batch_size x num_features x height x width’</li>
<li><strong>eps</strong> – 给分母加上的值,保证数值稳定(分母不能趋近0或取0),默认为 1e-5</li>
<li><strong>momentum</strong> – 动态均值和动态方差使用的移动动量值,默认为 0.1</li>
<li><strong>affine</strong> – 布尔值,设为 True 时,表示该层添加可学习,可改变的仿射参数,即 gamma 和 beta,默认为 True</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H, W)\)</code></li>
<li>Output: <code>\((N, C, H, W)\)</code> (same shape as input)</li>
</ul>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm2d(100)
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm2d(100, affine=False)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 100, 35, 45))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="batchnorm3d">BatchNorm3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.BatchNorm3d(num_features, eps=1e-05, momentum=0.1, affine=True)</code></pre>


<p>对小批量 (mini-batch) 4d 数据组成的 5d 输入进行标准化 (Batch Normalization) 操作.</p>
<pre class="codehilite"><code class="language-py">\[y = \frac{x - mean[x]}{ \sqrt{Var[x] + \epsilon}} * gamma + beta\]</code></pre>


<p>每个小批量数据中,计算各个维度的均值和标准差, 并且 gamma 和 beta 是大小为 C 的可学习,可改变的仿射参数向量 (C 为输入大小).</p>
<p>在训练过程中,该层计算均值和方差,并进行平均移动.默认的平均移动动量值为 0.1.</p>
<p>在验证时,训练得到的均值/方差,用于标准化验证数据.</p>
<p>BatchNorm 在 ‘C’ 维上处理,即 ‘(N, D, H, W)’ 部分运行,被称作 ‘Volumetric BatchNorm’ 或者 ‘Spatio-temporal BatchNorm’</p>
<p>| Parameters: | </p>
<ul>
<li><strong>num_features</strong> – 预期输入的特征数,大小为 ‘batch_size x num_features x depth x height x width’</li>
<li><strong>eps</strong> – 给分母加上的值,保证数值稳定(分母不能趋近0或取0),默认为 1e-5</li>
<li><strong>momentum</strong> – 动态均值和动态方差使用的移动动量值,默认为 0.1</li>
<li><strong>affine</strong> – 布尔值,设为 True 时,表示该层添加可学习,可改变的仿射参数,即 gamma 和 beta,默认为 True</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, D, H, W)\)</code></li>
<li>Output: <code>\((N, C, D, H, W)\)</code> (same shape as input)</li>
</ul>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm3d(100)
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm3d(100, affine=False)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 100, 35, 45, 10))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="instancenorm1d">InstanceNorm1d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.InstanceNorm1d(num_features, eps=1e-05, momentum=0.1, affine=False)</code></pre>


<p>对 2d 或者 3d 的小批量 (mini-batch) 数据进行实例标准化 (Instance Normalization) 操作. .. math:</p>
<pre class="codehilite"><code class="language-py">y = \frac{x - mean[x]}{ \sqrt{Var[x]} + \epsilon} * gamma + beta</code></pre>


<p>对小批量数据中的每一个对象,计算其各个维度的均值和标准差,并且 gamma 和 beta 是大小为 C 的可学习, 可改变的仿射参数向量( C 为输入大小).</p>
<p>在训练过程中,该层计算均值和方差,并进行平均移动,默认的平均移动动量值为 0.1.</p>
<p>在验证时 (&lt;cite&gt;.eval()&lt;/cite&gt;),InstanceNorm 模型默认保持不变,即求得的均值/方差不用于标准化验证数据, 但可以用 &lt;cite&gt;.train(False)&lt;/cite&gt; 方法强制使用存储的均值和方差.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>num_features</strong> – 预期输入的特征数,大小为 ‘batch_size x num_features x width’</li>
<li><strong>eps</strong> – 给分母加上的值,保证数值稳定(分母不能趋近0或取0),默认为 1e-5</li>
<li><strong>momentum</strong> – 动态均值和动态方差使用的移动动量值,默认为 0.1</li>
<li><strong>affine</strong> – 布尔值,设为 <code>True</code> 时,表示该层添加可学习,可改变的仿射参数,即 gamma 和 beta,默认为 <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, L)\)</code></li>
<li>Output: <code>\((N, C, L)\)</code> (same shape as input)</li>
</ul>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm1d(100)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm1d(100, affine=True)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 100, 40))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="instancenorm2d">InstanceNorm2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.InstanceNorm2d(num_features, eps=1e-05, momentum=0.1, affine=False)</code></pre>


<p>对小批量 (mini-batch) 3d 数据组成的 4d 输入进行实例标准化 (Batch Normalization) 操作. .. math:</p>
<pre class="codehilite"><code class="language-py">y = \frac{x - mean[x]}{ \sqrt{Var[x]} + \epsilon} * gamma + beta</code></pre>


<p>对小批量数据中的每一个对象,计算其各个维度的均值和标准差,并且 gamma 和 beta 是大小为 C 的可学习, 可改变的仿射参数向量( C 为输入大小).</p>
<p>在训练过程中,该层计算均值和方差,并进行平均移动,默认的平均移动动量值为 0.1.</p>
<p>在验证时 (&lt;cite&gt;.eval()&lt;/cite&gt;),InstanceNorm 模型默认保持不变,即求得的均值/方差不用于标准化验证数据, 但可以用 &lt;cite&gt;.train(False)&lt;/cite&gt; 方法强制使用存储的均值和方差.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>num_features</strong> – 预期输入的特征数,大小为 ‘batch_size x num_features x height x width’</li>
<li><strong>eps</strong> – 给分母加上的值,保证数值稳定(分母不能趋近0或取0),默认为 1e-5</li>
<li><strong>momentum</strong> – 动态均值和动态方差使用的移动动量值,默认为 0.1</li>
<li><strong>affine</strong> – 布尔值,设为 <code>True</code> 时,表示该层添加可学习,可改变的仿射参数,即 gamma 和 beta,默认为 <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H, W)\)</code></li>
<li>Output: <code>\((N, C, H, W)\)</code> (same shape as input)</li>
</ul>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm2d(100)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm2d(100, affine=True)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 100, 35, 45))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="instancenorm3d">InstanceNorm3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.InstanceNorm3d(num_features, eps=1e-05, momentum=0.1, affine=False)</code></pre>


<p>对小批量 (mini-batch) 4d 数据组成的 5d 输入进行实例标准化 (Batch Normalization) 操作. .. math:</p>
<pre class="codehilite"><code class="language-py">y = \frac{x - mean[x]}{ \sqrt{Var[x]} + \epsilon} * gamma + beta</code></pre>


<p>对小批量数据中的每一个对象,计算其各个维度的均值和标准差,并且 gamma 和 beta 是大小为 C 的可学习, 可改变的仿射参数向量( C 为输入大小).</p>
<p>在训练过程中,该层计算均值和方差,并进行平均移动,默认的平均移动动量值为 0.1.</p>
<p>在验证时 (&lt;cite&gt;.eval()&lt;/cite&gt;),InstanceNorm 模型默认保持不变,即求得的均值/方差不用于标准化验证数据, 但可以用 &lt;cite&gt;.train(False)&lt;/cite&gt; 方法强制使用存储的均值和方差.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>num_features</strong> – 预期输入的特征数,大小为 ‘batch_size x num_features x depth x height x width’</li>
<li><strong>eps</strong> – 给分母加上的值,保证数值稳定(分母不能趋近0或取0),默认为 1e-5</li>
<li><strong>momentum</strong> – 动态均值和动态方差使用的移动动量值,默认为 0.1</li>
<li><strong>affine</strong> – 布尔值,设为 <code>True</code> 时,表示该层添加可学习,可改变的仿射参数,即 gamma 和 beta,默认为 <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, D, H, W)\)</code></li>
<li>Output: <code>\((N, C, D, H, W)\)</code> (same shape as input)</li>
</ul>
<p>Examples</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm3d(100)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm3d(100, affine=True)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 100, 35, 45, 10))
&gt;&gt;&gt; output = m(input)</code></pre>


<h2 id="recurrent-layers">Recurrent layers (循环层)</h2>
<h3 id="rnn">RNN</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.RNN(*args, **kwargs)</code></pre>


<p>对于输入序列使用一个多层的 <code>Elman RNN</code>, 它的激活函数为 <code>tanh</code> 或者 <code>ReLU</code> .</p>
<p>对输入序列中每个元素, 每层计算公式为:</p>
<pre class="codehilite"><code class="language-py">\[h_t = \tanh(w_{ih} * x_t + b_{ih} + w_{hh} * h_{(t-1)} + b_{hh})\]</code></pre>


<p>这里 <code>\(h_t\)</code> 是当前在时刻 &lt;cite&gt;t&lt;/cite&gt; 的隐状态, 并且 <code>\(x_t\)</code> 是之前一层在 &lt;cite&gt;t&lt;/cite&gt; 时刻的隐状态, 或者是第一层的输入. 如果 <code>nonlinearity='relu'</code> ,那么将使用 relu 代替 tanh 作为激活函数.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>input_size</strong> – 输入 x 的特征数量</li>
<li><strong>hidden_size</strong> – 隐状态 <code>h</code> 中的特征数量</li>
<li><strong>num_layers</strong> – RNN 的层数</li>
<li><strong>nonlinearity</strong> – 指定非线性函数使用 [‘tanh’&#124;’relu’]. 默认: ‘tanh’</li>
<li><strong>bias</strong> – 如果是 <code>False</code> , 那么 RNN 层就不会使用偏置权重 b_ih 和 b_hh, 默认: <code>True</code></li>
<li><strong>batch_first</strong> – 如果 <code>True</code>, 那么输入 <code>Tensor</code> 的 shape 应该是 (batch, seq, feature),并且输出也是一样</li>
<li><strong>dropout</strong> – 如果值非零, 那么除了最后一层外, 其它层的输出都会套上一个 <code>dropout</code> 层</li>
<li><strong>bidirectional</strong> – 如果 <code>True</code> , 将会变成一个双向 RNN, 默认为 <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Inputs: input, h_0</p>
<ul>
<li><strong>input</strong> (seq_len, batch, input_size): 包含输入序列特征的 <code>tensor</code> , <code>input</code> 可以是被填充的变长序列.细节请看 <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> .</li>
<li><strong>h_0</strong> (num_layers * num_directions, batch, hidden_size): 包含 <code>batch</code> 中每个元素保存着初始隐状态的 <code>tensor</code></li>
</ul>
<p>Outputs: output, h_n</p>
<ul>
<li><strong>output</strong> (seq_len, batch, hidden_size * num_directions): 包含 RNN 最后一层输出特征 (h_k) 的 <code>tensor</code> 对于每个 k ,如果输入是一个 <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> , 那么输出也是一个可以是被填充的变长序列.</li>
<li><strong>h_n</strong> (num_layers * num_directions, batch, hidden_size): 包含 k= seq_len 隐状态的 <code>tensor</code>.</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih_l[k]</strong> – 第 k 层的 input-hidden 权重,可学习, shape 是 &lt;cite&gt;(input_size x hidden_size)&lt;/cite&gt;</li>
<li><strong>weight_hh_l[k]</strong> – 第 k 层的 hidden-hidden 权重, 可学习, shape 是 &lt;cite&gt;(hidden_size x hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_ih_l[k]</strong> – 第 k 层的 input-hidden 偏置, 可学习, shape 是 &lt;cite&gt;(hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_hh_l[k]</strong> – 第 k 层的 hidden-hidden 偏置, 可学习, shape 是 &lt;cite&gt;(hidden_size)&lt;/cite&gt;</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; rnn = nn.RNN(10, 20, 2)
&gt;&gt;&gt; input = Variable(torch.randn(5, 3, 10))
&gt;&gt;&gt; h0 = Variable(torch.randn(2, 3, 20))
&gt;&gt;&gt; output, hn = rnn(input, h0)</code></pre>


<h3 id="lstm">LSTM</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.LSTM(*args, **kwargs)</code></pre>


<p>对于输入序列使用一个多层的 <code>LSTM</code> ( long short-term memory ).</p>
<p>对输入序列的每个元素, <code>LSTM</code> 的每层都会执行以下计算:</p>
<pre class="codehilite"><code class="language-py">\[\begin{split}\begin{array}{ll} i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\ f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\ g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\ o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\ c_t = f_t * c_{(t-1)} + i_t * g_t \\ h_t = o_t * \tanh(c_t) \end{array}\end{split}\]</code></pre>


<p>这里 <code>\(h_t\)</code> 是在时刻 &lt;cite&gt;t&lt;/cite&gt; 的隐状态, <code>\(c_t\)</code> 是在时刻 &lt;cite&gt;t&lt;/cite&gt; 的细胞状态 (cell state), <code>\(x_t\)</code> 是上一层的在时刻 &lt;cite&gt;t&lt;/cite&gt; 的隐状态或者是第一层的 <code>\(input_t\)</code> , 而 <code>\(i_t\)</code>, <code>\(f_t\)</code>, <code>\(g_t\)</code>, <code>\(o_t\)</code> 分别代表 输入门,遗忘门,细胞和输出门.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>input_size</strong> – 输入的特征维度</li>
<li><strong>hidden_size</strong> – 隐状态的特征维度</li>
<li><strong>num_layers</strong> – 层数(和时序展开要区分开)</li>
<li><strong>bias</strong> – 如果为 <code>False</code> ,那么 LSTM 将不会使用 b_ih 和 b_hh ,默认: <code>True</code></li>
<li><strong>batch_first</strong> – 如果为 <code>True</code> , 那么输入和输出 Tensor 的形状为 (batch, seq, feature)</li>
<li><strong>dropout</strong> – 如果非零的话, 将会在 RNN 的输出上加个 dropout , 最后一层除外</li>
<li><strong>bidirectional</strong> – 如果为 <code>True</code>,将会变成一个双向 RNN ,默认为 <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Inputs: input, (h_0, c_0)</p>
<ul>
<li><strong>input</strong> (seq_len, batch, input_size): 包含输入序列特征的 <code>tensor</code> . 也可以是 <code>packed variable length sequence</code>, 详见 <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> .</li>
<li><strong>h_0</strong> (num_layers * num_directions, batch, hidden_size): 包含 batch 中每个元素的初始化隐状态的 <code>tensor</code> .</li>
<li><strong>c_0</strong> (num_layers * num_directions, batch, hidden_size): 包含 batch 中每个元素的初始化细胞状态的 <code>tensor</code> .</li>
</ul>
<p>Outputs: output, (h_n, c_n)</p>
<ul>
<li><strong>output</strong> (seq_len, batch, hidden_size * num_directions): 包含 RNN 最后一层的输出特征 &lt;cite&gt;(h_t)&lt;/cite&gt; 的 <code>tensor</code> , 对于每个 t . 如果输入是 <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> 那么输出也是一个可以是被填充的变长序列.</li>
<li><strong>h_n</strong> (num_layers * num_directions, batch, hidden_size): 包含 t=seq_len 隐状态的 <code>tensor</code>.</li>
<li><strong>c_n</strong> (num_layers * num_directions, batch, hidden_size): 包含 t=seq_len 细胞状态的 <code>tensor</code>.</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih_l[k]</strong> – 第 k 层可学习的 input-hidden 权重 &lt;cite&gt;(W_ii&#124;W_if&#124;W_ig&#124;W_io)&lt;/cite&gt;, shape 是 &lt;cite&gt;(4*hidden_size x input_size)&lt;/cite&gt;</li>
<li><strong>weight_hh_l[k]</strong> – 第 k 层可学习的 hidden-hidden 权重 &lt;cite&gt;(W_hi&#124;W_hf&#124;W_hg&#124;W_ho)&lt;/cite&gt;, shape 是 &lt;cite&gt;(4*hidden_size x hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_ih_l[k]</strong> – 第 k 层可学习的 input-hidden 偏置 &lt;cite&gt;(b_ii&#124;b_if&#124;b_ig&#124;b_io)&lt;/cite&gt;, shape 是 &lt;cite&gt;(4*hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_hh_l[k]</strong> – 第 k 层可学习的 hidden-hidden 偏置 &lt;cite&gt;(b_hi&#124;b_hf&#124;b_hg&#124;b_ho)&lt;/cite&gt;, shape 是 &lt;cite&gt;(4*hidden_size)&lt;/cite&gt;</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; rnn = nn.LSTM(10, 20, 2)
&gt;&gt;&gt; input = Variable(torch.randn(5, 3, 10))
&gt;&gt;&gt; h0 = Variable(torch.randn(2, 3, 20))
&gt;&gt;&gt; c0 = Variable(torch.randn(2, 3, 20))
&gt;&gt;&gt; output, hn = rnn(input, (h0, c0))</code></pre>


<h3 id="gru">GRU</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.GRU(*args, **kwargs)</code></pre>


<p>对于输入序列使用一个多层的 <code>GRU</code> (gated recurrent unit).</p>
<p>对输入序列的每个元素, 每层都会执行以下计算:</p>
<pre class="codehilite"><code class="language-py">\[\begin{split}\begin{array}{ll} r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\ z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\ n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\ h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\ \end{array}\end{split}\]</code></pre>


<p>这里 <code>\(h_t\)</code> 是在时刻 &lt;cite&gt;t&lt;/cite&gt; 的隐状态, <code>\(x_t\)</code> 是前一层在时刻 &lt;cite&gt;t&lt;/cite&gt; 的隐状态或者是第一层的 <code>\(input_t\)</code> , 而 <code>\(r_t\)</code>, <code>\(z_t\)</code>, <code>\(n_t\)</code> 分别是重置门,输入门和新门.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>input_size</strong> – 输入的特征维度</li>
<li><strong>hidden_size</strong> – 隐状态的特征维度</li>
<li><strong>num_layers</strong> – RNN 的层数</li>
<li><strong>bias</strong> – 如果为 <code>False</code>, 那么 RNN 层将不会使用偏置权重 b_ih 和 b_hh 默认: <code>True</code></li>
<li><strong>batch_first</strong> – 如果为 <code>True</code>, 那么输入和输出的 <code>tensor</code> 的形状是 (batch, seq, feature)</li>
<li><strong>dropout</strong> – 如果非零的话,将会在 RNN 的输出上加个 dropout ,最后一层除外</li>
<li><strong>bidirectional</strong> – 如果为 <code>True</code>, 将会变成一个双向 RNN . 默认: <code>False</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Inputs: input, h_0</p>
<ul>
<li><strong>input</strong> (seq_len, batch, input_size): 包含输入序列特征的 <code>tensor</code> . 也可以是 <code>packed variable length sequence</code>, 详见 <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> .</li>
<li><strong>h_0</strong> (num_layers * num_directions, batch, hidden_size): 包含 batch 中每个元素的初始化隐状态的 <code>tensor</code></li>
</ul>
<p>Outputs: output, h_n</p>
<ul>
<li><strong>output</strong> (seq_len, batch, hidden_size * num_directions): 包含 RNN 最后一层的输出特征 &lt;cite&gt;(h_t)&lt;/cite&gt; 的 <code>tensor</code> , 对于每个 t . 如果输入是 <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> 那么输出也是一个可以是被填充的变长序列.</li>
<li><strong>h_n</strong> (num_layers * num_directions, batch, hidden_size): 包含 t=seq_len 隐状态的 <code>tensor</code>.</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih_l[k]</strong> – 第 k 层可学习的 input-hidden 权重 (W_ir&#124;W_iz&#124;W_in), shape 为 &lt;cite&gt;(3*hidden_size x input_size)&lt;/cite&gt;</li>
<li><strong>weight_hh_l[k]</strong> – 第 k 层可学习的 hidden-hidden 权重 (W_hr&#124;W_hz&#124;W_hn), shape 为 &lt;cite&gt;(3*hidden_size x hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_ih_l[k]</strong> – 第 k 层可学习的 input-hidden 偏置 (b_ir&#124;b_iz&#124;b_in), shape 为 &lt;cite&gt;(3*hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_hh_l[k]</strong> – 第 k 层可学习的 hidden-hidden 偏置 (b_hr&#124;b_hz&#124;b_hn), shape 为 &lt;cite&gt;(3*hidden_size)&lt;/cite&gt;</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; rnn = nn.GRU(10, 20, 2)
&gt;&gt;&gt; input = Variable(torch.randn(5, 3, 10))
&gt;&gt;&gt; h0 = Variable(torch.randn(2, 3, 20))
&gt;&gt;&gt; output, hn = rnn(input, h0)</code></pre>


<h3 id="rnncell">RNNCell</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.RNNCell(input_size, hidden_size, bias=True, nonlinearity='tanh')</code></pre>


<p>一个 <code>Elan RNN cell</code> , 激活函数是 tanh 或 ReLU , 用于输入序列.</p>
<pre class="codehilite"><code class="language-py">\[h' = \tanh(w_{ih} * x + b_{ih} + w_{hh} * h + b_{hh})\]</code></pre>


<p>如果 nonlinearity=’relu’, 那么将会使用 ReLU 来代替 tanh .</p>
<p>| Parameters: | </p>
<ul>
<li><strong>input_size</strong> – 输入的特征维度</li>
<li><strong>hidden_size</strong> – 隐状态的特征维度</li>
<li><strong>bias</strong> – 如果为 <code>False</code>, 那么RNN层将不会使用偏置权重 b_ih 和 b_hh. 默认: <code>True</code></li>
<li><strong>nonlinearity</strong> – 用于选择非线性激活函数 [‘tanh’&#124;’relu’]. 默认: ‘tanh’</li>
</ul>
<p>|
| --- | --- |</p>
<p>Inputs: input, hidden</p>
<ul>
<li><strong>input</strong> (batch, input_size): 包含输入特征的 <code>tensor</code> .</li>
<li><strong>hidden</strong> (batch, hidden_size): 包含 batch 中每个元素的初始化隐状态的 <code>tensor</code>.</li>
</ul>
<p>Outputs: h’</p>
<ul>
<li><strong>h’</strong> (batch, hidden_size): 保存着 batch 中每个元素的下一层隐状态的 <code>tensor</code> .</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih</strong> – <code>input-hidden</code> 权重, 可学习, shape 为 &lt;cite&gt;(input_size x hidden_size)&lt;/cite&gt;</li>
<li><strong>weight_hh</strong> – <code>hidden-hidden</code> 权重, 可学习, shape 为 &lt;cite&gt;(hidden_size x hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_ih</strong> – <code>input-hidden</code> 偏置,可学习, shape 为 &lt;cite&gt;(hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_hh</strong> – <code>hidden-hidden</code> 偏置,可学习, shape 为 &lt;cite&gt;(hidden_size)&lt;/cite&gt;</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; rnn = nn.RNNCell(10, 20)
&gt;&gt;&gt; input = Variable(torch.randn(6, 3, 10))
&gt;&gt;&gt; hx = Variable(torch.randn(3, 20))
&gt;&gt;&gt; output = []
&gt;&gt;&gt; for i in range(6):
...     hx = rnn(input[i], hx)
...     output.append(hx)</code></pre>


<h3 id="lstmcell">LSTMCell</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.LSTMCell(input_size, hidden_size, bias=True)</code></pre>


<p>LSTM 细胞.</p>
<pre class="codehilite"><code class="language-py">\[\begin{split}\begin{array}{ll} i = \mathrm{sigmoid}(W_{ii} x + b_{ii} + W_{hi} h + b_{hi}) \\ f = \mathrm{sigmoid}(W_{if} x + b_{if} + W_{hf} h + b_{hf}) \\ g = \tanh(W_{ig} x + b_{ig} + W_{hc} h + b_{hg}) \\ o = \mathrm{sigmoid}(W_{io} x + b_{io} + W_{ho} h + b_{ho}) \\ c' = f * c + i * g \\ h' = o * \tanh(c') \\ \end{array}\end{split}\]</code></pre>


<p>| Parameters: | </p>
<ul>
<li><strong>input_size</strong> – 输入的特征维度</li>
<li><strong>hidden_size</strong> – 隐状态的维度</li>
<li><strong>bias</strong> – 如果为 &lt;cite&gt;False&lt;/cite&gt;, 那么RNN层将不会使用偏置权重 b_ih 和 b_hh 默认: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Inputs: input, (h_0, c_0)</p>
<ul>
<li><strong>input</strong> (batch, input_size): 包含输入特征的 <code>tensor</code> .</li>
<li><strong>h_0</strong> (batch, hidden_size): 包含 batch 中每个元素的初始化隐状态的 <code>tensor</code>.</li>
<li><strong>c_0</strong> (batch. hidden_size): 包含 batch 中每个元素的初始化细胞状态的 <code>tensor</code></li>
</ul>
<p>Outputs: h_1, c_1</p>
<ul>
<li><strong>h_1</strong> (batch, hidden_size): 保存着 batch 中每个元素的下一层隐状态的 <code>tensor</code></li>
<li><strong>c_1</strong> (batch, hidden_size): 保存着 batch 中每个元素的下一细胞状态的 <code>tensor</code></li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih</strong> – <code>input-hidden</code> 权重, 可学习, 形状为 &lt;cite&gt;(4*hidden_size x input_size)&lt;/cite&gt;</li>
<li><strong>weight_hh</strong> – <code>hidden-hidden</code> 权重, 可学习, 形状为 &lt;cite&gt;(4*hidden_size x hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_ih</strong> – <code>input-hidden</code> 偏置, 可学习, 形状为 &lt;cite&gt;(4*hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_hh</strong> – <code>hidden-hidden</code> 偏置, 可学习, 形状为 &lt;cite&gt;(4*hidden_size)&lt;/cite&gt;</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; rnn = nn.LSTMCell(10, 20)
&gt;&gt;&gt; input = Variable(torch.randn(6, 3, 10))
&gt;&gt;&gt; hx = Variable(torch.randn(3, 20))
&gt;&gt;&gt; cx = Variable(torch.randn(3, 20))
&gt;&gt;&gt; output = []
&gt;&gt;&gt; for i in range(6):
...     hx, cx = rnn(input[i], (hx, cx))
...     output.append(hx)</code></pre>


<h3 id="grucell">GRUCell</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.GRUCell(input_size, hidden_size, bias=True)</code></pre>


<p>GRU 细胞</p>
<pre class="codehilite"><code class="language-py">\[\begin{split}\begin{array}{ll} r = \mathrm{sigmoid}(W_{ir} x + b_{ir} + W_{hr} h + b_{hr}) \\ z = \mathrm{sigmoid}(W_{iz} x + b_{iz} + W_{hz} h + b_{hz}) \\ n = \tanh(W_{in} x + b_{in} + r * (W_{hn} h + b_{hn})) \\ h' = (1 - z) * n + z * h \end{array}\end{split}\]</code></pre>


<p>| Parameters: | </p>
<ul>
<li><strong>input_size</strong> – 输入的特征维度</li>
<li><strong>hidden_size</strong> – 隐状态的维度</li>
<li><strong>bias</strong> – 如果为 &lt;cite&gt;False&lt;/cite&gt;, 那么RNN层将不会使用偏置权重 b_ih 和 b_hh 默认: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Inputs: input, hidden</p>
<ul>
<li><strong>input</strong> (batch, input_size): 包含输入特征的 <code>tensor</code> .</li>
<li><strong>hidden</strong> (batch, hidden_size): 包含 batch 中每个元素的初始化隐状态的 <code>tensor</code>.</li>
</ul>
<p>Outputs: h’</p>
<ul>
<li><strong>h’</strong>: (batch, hidden_size): 保存着 batch 中每个元素的下一层隐状态的 <code>tensor</code></li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih</strong> – <code>input-hidden</code> 权重, 可学习, shape 为, &lt;cite&gt;(3*hidden_size x input_size)&lt;/cite&gt;</li>
<li><strong>weight_hh</strong> – <code>hidden-hidden</code> 权重, 可学习, shape 为 &lt;cite&gt;(3*hidden_size x hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_ih</strong> – <code>input-hidden</code> 偏置, 可学习, shape 为 &lt;cite&gt;(3*hidden_size)&lt;/cite&gt;</li>
<li><strong>bias_hh</strong> – <code>hidden-hidden</code> 偏置, 可学习, shape 为 &lt;cite&gt;(3*hidden_size)&lt;/cite&gt;</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; rnn = nn.GRUCell(10, 20)
&gt;&gt;&gt; input = Variable(torch.randn(6, 3, 10))
&gt;&gt;&gt; hx = Variable(torch.randn(3, 20))
&gt;&gt;&gt; output = []
&gt;&gt;&gt; for i in range(6):
...     hx = rnn(input[i], hx)
...     output.append(hx)</code></pre>


<h2 id="linear-layers">Linear layers (线性层)</h2>
<h3 id="linear">Linear</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Linear(in_features, out_features, bias=True)</code></pre>


<p>对输入数据进行线性变换: <code>\(y = Ax + b\)</code></p>
<p>| Parameters: | </p>
<ul>
<li><strong>in_features</strong> – 每个输入样本的大小</li>
<li><strong>out_features</strong> – 每个输出样本的大小</li>
<li><strong>bias</strong> – 若设置为 False, 这层不会学习偏置. 默认值: True</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, *, in\_features)\)</code> 这里 &lt;cite&gt;*&lt;/cite&gt; 意味着可以添加任意数量的其他维度</li>
<li>Output: <code>\((N, *, out\_features)\)</code> 除了最后一个维度外, 其余的都与输入相同</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> – 形状为 (out_features x in_features) 的模块中可学习的权值</li>
<li><strong>bias</strong> – 形状为 (out_features) 的模块中可学习的偏置</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Linear(20, 30)
&gt;&gt;&gt; input = autograd.Variable(torch.randn(128, 20))
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; print(output.size())</code></pre>


<h3 id="bilinear">Bilinear</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Bilinear(in1_features, in2_features, out_features, bias=True)</code></pre>


<p>对输入数据进行双线性变换: <code>\(y = x_1 * A * x_2 + b\)</code></p>
<p>| Parameters: | </p>
<ul>
<li><strong>in1_features</strong> – 输入一的每个输入样本的大小</li>
<li><strong>in2_features</strong> – 输入二的每个输入样本的大小</li>
<li><strong>out_features</strong> – 每个输出样本的大小</li>
<li><strong>bias</strong> – 若设置为False, 这层不会学习偏置. 默认值: True</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, in1\_features)\)</code>, <code>\((N, in2\_features)\)</code></li>
<li>Output: <code>\((N, out\_features)\)</code></li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> – 形状为 (out_features x in1_features x in2_features) 的模块中可学习的权值</li>
<li><strong>bias</strong> – 形状为 (out_features) 的模块中可学习的偏置</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Bilinear(20, 30, 40)
&gt;&gt;&gt; input1 = autograd.Variable(torch.randn(128, 20))
&gt;&gt;&gt; input2 = autograd.Variable(torch.randn(128, 30))
&gt;&gt;&gt; output = m(input1, input2)
&gt;&gt;&gt; print(output.size())</code></pre>


<h2 id="dropout-layers">Dropout layers</h2>
<h3 id="dropout">Dropout</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Dropout(p=0.5, inplace=False)</code></pre>


<p>Dropout 在训练期间, 按照伯努利概率分布, 以概率 p 随机地将输入张量中的部分元素</p>
<p>置为 0, 在每次调用时, 被置为 0 的元素是随机的.</p>
<p>Dropout 已被证明是正则化的一个行之有效的技术, 并且在防止神经元之间互适应问题上 也卓有成效.（神经元互适应问题详见论文 <a href="https://arxiv.org/abs/1207.0580">Improving neural networks by preventing co-adaptation of feature detectors</a> ）</p>
<p>并且, Dropout 的输出均与 <em>1/(1-p)</em> 的比例系数进行了相乘, 保证了求值时函数是归一化的.</p>
<p>Args: p: 元素被置为0的概率, 默认值: 0.5 inplace: 如果为 True, 置0操作将直接发生在传入的元素上.默认值: false Shape:</p>
<ul>
<li>Input: any.输入数据可以是任何大小</li>
<li>Output: Same.输出数据大小与输入相同</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Dropout(p=0.2)</code></pre>


<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16))
&gt;&gt;&gt; output = m(input)</code></pre>


<h3 id="dropout2d">Dropout2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Dropout2d(p=0.5, inplace=False)</code></pre>


<p>Dropout2d 将输入张量的所有通道随机地置为 0.被置为 0 的通道在每次调用时是随机的.</p>
<blockquote>
<p>通常输入数据来自 Conv2d 模块.</p>
<p>在论文 <a href="http://arxiv.org/abs/1411.4280">Efficient Object Localization Using Convolutional Networks</a> 中有如下 描述: 如果特征映射中的邻接像素是强相关的（在早期的卷积层中很常见）, 那么独立同分布 的 dropout 将不会正则化激活函数, 相反其会导致有效的学习率的下降.</p>
<p>在这样的情况下, 应该使用函数函数 nn.Dropout2d , 它能够提升特征映射之间的独立性.</p>
<p>Args: p (float,optional): 元素被置0的概率 inplace（bool, optional）: 如果被设为’True’, 置0操作将直接作用在输入元素上 Shape:</p>
<ul>
<li>Input: math:(N, C, H, W)</li>
<li>Output: math:(N, C, H, W) （与输入相同）</li>
</ul>
<p>Examples:</p>
<p>```py
&gt;&gt;&gt; m = nn.Dropout2d(p=0.2)</p>
<p>```</p>
<p>```py
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 32, 32))
&gt;&gt;&gt; output = m(input)</p>
<p>```</p>
</blockquote>
<h3 id="dropout3d">Dropout3d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Dropout3d(p=0.5, inplace=False)</code></pre>


<p>Dropout3d 将输入张量的所有通道随机地置为 0.被置为 0 的通道在每次调用时是随机的.</p>
<blockquote>
<p>通常输入数据来自 Conv3d 模块.</p>
<p>在论文 <a href="http://arxiv.org/abs/1411.4280">Efficient Object Localization Using Convolutional Networks</a> 中有如下 描述: 如果特征映射中的邻接像素是强相关的（在早期的卷积层中很常见）, 那么独立同分布 的 dropout 将不会正则化激活函数, 相反其会导致有效的学习率的下降.</p>
<p>在这样的情况下, 应该使用函数函数 nn.Dropout3d , 它能够促进特征映射之间的独立性.</p>
<p>Args: p (float,optional): 元素被置0的概率 inplace（bool, optional）: 如果被设为 True , 置0操作将直接作用在输入元素上 Shape:</p>
<ul>
<li>Input: math:(N, C, H, W)</li>
<li>Output: math:(N, C, H, W) （与输入相同）</li>
</ul>
<p>Examples:</p>
<p>```py
&gt;&gt;&gt; m = nn.Dropout3d(p=0.2)</p>
<p>```</p>
<p>```py
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16, 4, 32, 32))
&gt;&gt;&gt; output = m(input)</p>
<p>```</p>
</blockquote>
<h3 id="alphadropout">AlphaDropout</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.AlphaDropout(p=0.5)</code></pre>


<p>在输入上应用 Alpha Dropout.</p>
<blockquote>
<p>Alpha Dropout 是一种维持自正交性质的 Dropout . 对于一个均值为 0 和标准差为 1 的输入 来说, Alpha Dropout 能保持原始数据的均值和标准差.Alpha Dropout 和 SELU 激活函数 携手同行, 后者也保证了输出拥有与输入相同的均值和标准差.</p>
<p>Alpha Dropout 在训练期间, 按照伯努利概率分布, 以概率 p 随机地将输入张量中的部分元素 置进行掩盖, 在每次调用中, 被掩盖的元素是随机的, 并且对输出会进行缩放、变换等操作 以保持均值为 0、标准差为 1.</p>
<p>在求值期间, 模块简单的计算一个归一化的函数.</p>
<p>更多信息请参考论文: Self-Normalizing Neural Networks</p>
<p>Args: p（float）: 元素被掩盖的概率, 默认值: 0.5 Shape:</p>
<ul>
<li>Input: any.输入数据可以是任何大小</li>
<li>Output: Same.输出数据大小与输入相同</li>
</ul>
<p>Examples:</p>
<p>```py
&gt;&gt;&gt; m = nn.AlphaDropout(p=0.2)</p>
<p>```</p>
<p>```py
&gt;&gt;&gt; input = autograd.Variable(torch.randn(20, 16))
&gt;&gt;&gt; output = m(input)</p>
<p>```</p>
</blockquote>
<h2 id="sparse-layers">Sparse layers (稀疏层)</h2>
<h3 id="embedding">Embedding</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2, scale_grad_by_freq=False, sparse=False)</code></pre>


<p>一个简单的查找表, 存储了固定字典和大小的 embedding.</p>
<p>这个模块经常用来存储 word embeddings, 并通过索引来检索, 模块的输入是索引构成的列表, 输出是对应的 word embeddings.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>num_embeddings</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – embeddings 字典的大小</li>
<li><strong>embedding_dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – 每个 embedding 向量的大小</li>
<li><strong>padding_idx</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <em>optional</em>) – 如果给出, 在索引处, 输出补零</li>
<li><strong>max_norm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a><em>,</em> <em>optional</em>) – 如果给出, 重新归一化 embeddings, 使其范数小于该值</li>
<li><strong>norm_type</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a><em>,</em> <em>optional</em>) – 为 max_norm 选项计算 p 范数时 P</li>
<li><strong>scale_grad_by_freq</strong> (<em>boolean__,</em> <em>optional</em>) – 如果给出, 会根据 words 在 mini-batch 中的频率缩放梯度</li>
<li><strong>sparse</strong> (<em>boolean__,</em> <em>optional</em>) – 如果为 <code>True</code>, 关于权重矩阵的梯度是一个稀疏张量, 详情请参考稀疏梯度</li>
</ul>
<p>|
| --- | --- |
| Variables: | <strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – shape 为 (num_embeddings, embedding_dim) 的模块的可学习权重 |
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: LongTensor &lt;cite&gt;(N, W)&lt;/cite&gt;, N = mini-batch, W = 每个 mini-batch 中用来提取的索引数</li>
<li>Output: &lt;cite&gt;(N, W, embedding_dim)&lt;/cite&gt;</li>
</ul>
<p>Notes</p>
<p>请注意, 只支持有限数量的优化器. 稀疏梯度: 当前是 (&lt;cite&gt;cuda&lt;/cite&gt; 和 &lt;cite&gt;cpu&lt;/cite&gt;) 版本的 &lt;cite&gt;optim.SGD&lt;/cite&gt;, 和 (&lt;cite&gt;cpu&lt;/cite&gt;) 版本的 &lt;cite&gt;optim.Adagrad&lt;/cite&gt;.</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # an Embedding module containing 10 tensors of size 3
&gt;&gt;&gt; embedding = nn.Embedding(10, 3)
&gt;&gt;&gt; # a batch of 2 samples of 4 indices each
&gt;&gt;&gt; input = Variable(torch.LongTensor([[1,2,4,5],[4,3,2,9]]))
&gt;&gt;&gt; embedding(input)

Variable containing:
(0 ,.,.) =
 -1.0822  1.2522  0.2434
 0.8393 -0.6062 -0.3348
 0.6597  0.0350  0.0837
 0.5521  0.9447  0.0498

(1 ,.,.) =
 0.6597  0.0350  0.0837
 -0.1527  0.0877  0.4260
 0.8393 -0.6062 -0.3348
 -0.8738 -0.9054  0.4281
[torch.FloatTensor of size 2x4x3]

&gt;&gt;&gt; # example with padding_idx
&gt;&gt;&gt; embedding = nn.Embedding(10, 3, padding_idx=0)
&gt;&gt;&gt; input = Variable(torch.LongTensor([[0,2,0,5]]))
&gt;&gt;&gt; embedding(input)

Variable containing:
(0 ,.,.) =
 0.0000  0.0000  0.0000
 0.3452  0.4937 -0.9361
 0.0000  0.0000  0.0000
 0.0706 -2.1962 -0.6276
[torch.FloatTensor of size 1x4x3]</code></pre>


<h3 id="embeddingbag">EmbeddingBag</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.EmbeddingBag(num_embeddings, embedding_dim, max_norm=None, norm_type=2, scale_grad_by_freq=False, mode='mean')</code></pre>


<p>计算一 个’bags’ 里的 embedding s的均值或和, 不用实例化中间的 embeddings</p>
<p>对于固定长度的 bags</p>
<ul>
<li>nn.EmbeddingBag 和 &lt;cite&gt;mode=sum&lt;/cite&gt; 相当于 nn.Embedding 与之后的 &lt;cite&gt;torch.sum(dim=1)&lt;/cite&gt;</li>
<li>其与 &lt;cite&gt;mode=mean&lt;/cite&gt; 相当于 nn.Embedding 与之后的 &lt;cite&gt;torch.mean(dim=1)&lt;/cite&gt;</li>
</ul>
<p>然而, 比起一连串这样的操作, nn.EmbeddingBag 在时间和内存上更加高效.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>num_embeddings</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – embeddings 字典的大小</li>
<li><strong>embedding_dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – 每个 embedding 向量的大小</li>
<li><strong>max_norm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a><em>,</em> <em>optional</em>) – 如果给出, 重新归一化 embeddings, 使其范数小于该值</li>
<li><strong>norm_type</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a><em>,</em> <em>optional</em>) – 为 max_norm 选项计算 p 范数时的 P</li>
<li><strong>scale_grad_by_freq</strong> (<em>boolean__,</em> <em>optional</em>) – 如果给出, 会根据 words 在 mini-batch 中的频率缩放梯度</li>
<li><strong>mode</strong> (<a href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.6)"><em>string</em></a><em>,</em> <em>optional</em>) – ‘sum’ &#124; ‘mean’. 指定减少 bag 的方式. 默认: ‘mean’</li>
</ul>
<p>|
| --- | --- |
| Variables: | <strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – shape 为 (num_embeddings, embedding_dim) 的模块的可学习权重 |
| --- | --- |</p>
<p>Inputs: input, offsets</p>
<ul>
<li><strong>input</strong> (N or BxN): LongTensor, 包括要提取的 embeddings 的索引, 当 &lt;cite&gt;input&lt;/cite&gt; 是形状为 &lt;cite&gt;N&lt;/cite&gt; 的 1D 张量时, 一个给出的 &lt;cite&gt;offsets&lt;/cite&gt; 张量中包括: mini-batch 中每个新序列的起始位置</li>
<li><strong>offsets</strong> (B or None): LongTensor, 包括一个 mini-batch 的可变长度序列中的每个新样本的起始位置 如果 &lt;cite&gt;input&lt;/cite&gt; 是 2D (BxN) 的, offset 就不用再给出; 如果 &lt;cite&gt;input&lt;/cite&gt; 是一个 mini-batch 的固定长度的序列, 每个序列的长度为 &lt;cite&gt;N&lt;/cite&gt;</li>
</ul>
<p>Shape:</p>
<ul>
<li>Input: LongTensor &lt;cite&gt;N&lt;/cite&gt;, N = 要提取的 embeddings 的数量,</li>
</ul>
<blockquote>
<p>或者是 LongTensor &lt;cite&gt;BxN&lt;/cite&gt;, B = mini-batch 中序列的数量, N = 每个序列中 embeddings 的数量</p>
</blockquote>
<ul>
<li>Offsets: LongTensor &lt;cite&gt;B&lt;/cite&gt;, B = bags 的数量, 值为每个 bag 中 &lt;cite&gt;input&lt;/cite&gt; 的 offset, i.e. 是长度的累加. Offsets 不会给出, 如果 Input是 2D 的<code>BxN</code> 张量, 输入被认为是固定长度的序列</li>
<li>Output: &lt;cite&gt;(B, embedding_dim)&lt;/cite&gt;</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; # an Embedding module containing 10 tensors of size 3
&gt;&gt;&gt; embedding_sum = nn.EmbeddingBag(10, 3, mode='sum')
&gt;&gt;&gt; # a batch of 2 samples of 4 indices each
&gt;&gt;&gt; input = Variable(torch.LongTensor([1,2,4,5,4,3,2,9]))
&gt;&gt;&gt; offsets = Variable(torch.LongTensor([0,4]))
&gt;&gt;&gt; embedding_sum(input, offsets)

Variable containing:
-0.7296 -4.6926  0.3295
-0.5186 -0.5631 -0.2792
[torch.FloatTensor of size 2x3]</code></pre>


<h2 id="distance-functions">Distance functions (距离函数)</h2>
<h3 id="cosinesimilarity">CosineSimilarity</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.CosineSimilarity(dim=1, eps=1e-08)</code></pre>


<p>返回沿着 dim 方向计算的 x1 与 x2 之间的余弦相似度.</p>
<pre class="codehilite"><code class="language-py">\[\text{similarity} = \dfrac{x_1 \cdot x_2}{\max(\Vert x_1 \Vert _2 \cdot \Vert x_2 \Vert _2, \epsilon)}\]</code></pre>


<p>| Parameters: | </p>
<ul>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <em>optional</em>) – 计算余弦相似度的维度. Default: 1</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a><em>,</em> <em>optional</em>) – 小的值以避免被零除. Default: 1e-8</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input1: <code>\((\ast_1, D, \ast_2)\)</code>, 其中的 D 表示 &lt;cite&gt;dim&lt;/cite&gt; 的位置</li>
<li>Input2: <code>\((\ast_1, D, \ast_2)\)</code>, 与 Input1 一样的 shape</li>
<li>Output: <code>\((\ast_1, \ast_2)\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; input1 = autograd.Variable(torch.randn(100, 128))
&gt;&gt;&gt; input2 = autograd.Variable(torch.randn(100, 128))
&gt;&gt;&gt; cos = nn.CosineSimilarity(dim=1, eps=1e-6)
&gt;&gt;&gt; output = cos(input1, input2)
&gt;&gt;&gt; print(output)</code></pre>


<h3 id="pairwisedistance">PairwiseDistance</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.PairwiseDistance(p=2, eps=1e-06)</code></pre>


<p>计算向量 v1, v2 之间的 batchwise pairwise distance(分批成对距离):</p>
<pre class="codehilite"><code class="language-py">\[\Vert x \Vert _p := \left( \sum_{i=1}^n \vert x_i \vert ^ p \right) ^ {1/p}\]</code></pre>


<p>| Parameters: | </p>
<ul>
<li><strong>p</strong> (<em>real</em>) – norm degree(规范程度). Default: 2</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a><em>,</em> <em>optional</em>) – 小的值以避免被零除. Default: 1e-6</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input1: <code>\((N, D)\)</code>, 其中的 &lt;cite&gt;D = vector dimension(向量维度)&lt;/cite&gt;</li>
<li>Input2: <code>\((N, D)\)</code>, 与 Input1 的 shape 一样</li>
<li>Output: <code>\((N, 1)\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; pdist = nn.PairwiseDistance(p=2)
&gt;&gt;&gt; input1 = autograd.Variable(torch.randn(100, 128))
&gt;&gt;&gt; input2 = autograd.Variable(torch.randn(100, 128))
&gt;&gt;&gt; output = pdist(input1, input2)</code></pre>


<h2 id="loss-functions">Loss functions (损失函数)</h2>
<h3 id="l1loss">L1Loss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.L1Loss(size_average=True, reduce=True)</code></pre>


<p>创建一个衡量输入 &lt;cite&gt;x&lt;/cite&gt; 与目标 &lt;cite&gt;y&lt;/cite&gt; 之间差的绝对值的平均值的标准, 该 函数会逐元素地求出 &lt;cite&gt;x&lt;/cite&gt; 和 &lt;cite&gt;y&lt;/cite&gt; 之间差的绝对值, 最后返回绝对值的平均值.</p>
<p><code>\({loss}(x, y) = 1/n \sum |x_i - y_i|\)</code></p>
<p>&lt;cite&gt;x&lt;/cite&gt; 和 &lt;cite&gt;y&lt;/cite&gt; 可以是任意维度的数组, 但需要有相同数量的n个元素.</p>
<p>求和操作会对n个元素求和, 最后除以 &lt;cite&gt;n&lt;/cite&gt; .</p>
<p>在构造函数的参数中传入 &lt;cite&gt;size_average=False&lt;/cite&gt;, 最后求出来的绝对值将不会除以 &lt;cite&gt;n&lt;/cite&gt;.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量） 上取平均值. 如果字段 size_average 被设置为 <code>False</code>, loss 将会在每个 mini-batch（小批量） 上累加, 而不会取平均值. 当 reduce 的值为 <code>False</code> 时该字段会被忽略. 默认值: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量）上求平均值或者 求和. 当 reduce 是 <code>False</code> 时, 损失函数会对每个 batch 元素都返回一个 loss 并忽 略 size_average 字段. 默认值: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, *)\)</code>, &lt;cite&gt;*&lt;/cite&gt; 表示任意数量的额外维度</li>
<li>目标: <code>\((N, *)\)</code>, 和输入的shape相同</li>
<li>输出: 标量. 如果 reduce 是 <code>False</code> , 则输出为 <code>\((N, *)\)</code>, shape与输出相同</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; loss = nn.L1Loss()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(3, 5), requires_grad=True)
&gt;&gt;&gt; target = autograd.Variable(torch.randn(3, 5))
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()</code></pre>


<h3 id="mseloss">MSELoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MSELoss(size_average=True, reduce=True)</code></pre>


<p>输入 &lt;cite&gt;x&lt;/cite&gt; 和 目标 &lt;cite&gt;y&lt;/cite&gt; 之间的均方差</p>
<p><code>\({loss}(x, y) = 1/n \sum |x_i - y_i|^2\)</code></p>
<p>&lt;cite&gt;x&lt;/cite&gt; 和 &lt;cite&gt;y&lt;/cite&gt; 可以是任意维度的数组, 但需要有相同数量的n个元素.</p>
<p>求和操作会对n个元素求和, 最后除以 &lt;cite&gt;n&lt;/cite&gt;.</p>
<p>在构造函数的参数中传入 &lt;cite&gt;size_average=False&lt;/cite&gt; , 最后求出来的绝对值将不会除以 &lt;cite&gt;n&lt;/cite&gt;.</p>
<p>要得到每个 batch 中每个元素的 loss, 设置 &lt;cite&gt;reduce&lt;/cite&gt; 为 <code>False</code>. 返回的 loss 将不会 取平均值, 也不会被 &lt;cite&gt;size_average&lt;/cite&gt; 影响.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量） 上取平均值. 如果字段 size_average 被设置为 <code>False</code> , loss 会在每 个 mini-batch（小批量）上求和. 只有当 reduce 的值为 <code>True</code> 才会生效. 默认值: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会根据 size_average 的值在每 个 mini-batch（小批量）上求平均值或者求和. 当 reduce 是 <code>False</code> 时, 损失函数会对每 个 batch 元素都返回一个 loss 并忽略 size_average字段. 默认值: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, *)\)</code>, 其中 &lt;cite&gt;*&lt;/cite&gt; 表示任意数量的额外维度.</li>
<li>目标: <code>\((N, *)\)</code>, shape 跟输入相同</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; loss = nn.MSELoss()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(3, 5), requires_grad=True)
&gt;&gt;&gt; target = autograd.Variable(torch.randn(3, 5))
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()</code></pre>


<h3 id="crossentropyloss">CrossEntropyLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.CrossEntropyLoss(weight=None, size_average=True, ignore_index=-100, reduce=True)</code></pre>


<p>该类把 &lt;cite&gt;LogSoftMax&lt;/cite&gt; 和 &lt;cite&gt;NLLLoss&lt;/cite&gt; 结合到了一个类中</p>
<p>当训练有 &lt;cite&gt;C&lt;/cite&gt; 个类别的分类问题时很有效. 可选参数 &lt;cite&gt;weight&lt;/cite&gt; 必须是一个1维 Tensor, 权重将被分配给各个类别. 对于不平衡的训练集非常有效.</p>
<p>&lt;cite&gt;input&lt;/cite&gt; 含有每个类别的分数</p>
<p>&lt;cite&gt;input&lt;/cite&gt; 必须是一个2维的形如 &lt;cite&gt;(minibatch, C)&lt;/cite&gt; 的 &lt;cite&gt;Tensor&lt;/cite&gt;.</p>
<p>&lt;cite&gt;target&lt;/cite&gt; 是一个类别索引 (0 to C-1), 对应于 &lt;cite&gt;minibatch&lt;/cite&gt; 中的每个元素</p>
<p>loss 可以描述为:</p>
<pre class="codehilite"><code class="language-py">loss(x, class) = -log(exp(x[class]) / (\sum_j exp(x[j])))
               = -x[class] + log(\sum_j exp(x[j]))</code></pre>


<p>当 &lt;cite&gt;weight&lt;/cite&gt; 参数存在时:</p>
<pre class="codehilite"><code class="language-py">loss(x, class) = weight[class] * (-x[class] + log(\sum_j exp(x[j])))</code></pre>


<p>loss 在每个 mini-batch（小批量）上取平均值.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – 自定义的每个类别的权重. 必须是一个长度为 &lt;cite&gt;C&lt;/cite&gt; 的 Tensor</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量） 上取平均值. 如果字段 size_average 被设置为 <code>False</code>, loss 将会在每个 mini-batch（小批量） 上累加, 而不会取平均值. 当 reduce 的值为 <code>False</code> 时该字段会被忽略.</li>
<li><strong>ignore_index</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <em>optional</em>) – 设置一个目标值, 该目标值会被忽略, 从而不会影响到 输入的梯度. 当 size_average 字段为 <code>True</code> 时, loss 将会在没有被忽略的元素上 取平均.</li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会根据 size_average 的值在每 个 mini-batch（小批量）上求平均值或者求和. 当 reduce 是 <code>False</code> 时, 损失函数会对 每个 batch 元素都返回一个 loss 并忽略 size_average 字段. 默认值: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, C)\)</code>, 其中 &lt;cite&gt;C&lt;/cite&gt; 是类别的数量</li>
<li>目标: <code>\((N)\)</code>, 其中的每个元素都满足 &lt;cite&gt;0 &lt;= targets[i] &lt;= C-1&lt;/cite&gt;</li>
<li>输出: 标量. 如果 reduce 是 <code>False</code>, 则输出为 <code>\((N)\)</code>.</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; loss = nn.CrossEntropyLoss()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(3, 5), requires_grad=True)
&gt;&gt;&gt; target = autograd.Variable(torch.LongTensor(3).random_(5))
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()</code></pre>


<h3 id="nllloss">NLLLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.NLLLoss(weight=None, size_average=True, ignore_index=-100, reduce=True)</code></pre>


<p>负对数似然损失. 用于训练 &lt;cite&gt;C&lt;/cite&gt; 个类别的分类问题. 可选参数 &lt;cite&gt;weight&lt;/cite&gt; 是 一个1维的 Tensor, 用来设置每个类别的权重. 当训练集不平衡时该参数十分有用.</p>
<p>由前向传播得到的输入应该含有每个类别的对数概率: 输入必须是形如 &lt;cite&gt;(minibatch, C)&lt;/cite&gt; 的 2维 Tensor.</p>
<p>在一个神经网络的最后一层添加 &lt;cite&gt;LogSoftmax&lt;/cite&gt; 层可以得到对数概率. 如果你不希望在神经网络中 加入额外的一层, 也可以使用 &lt;cite&gt;CrossEntropyLoss&lt;/cite&gt; 函数.</p>
<p>该损失函数需要的目标值是一个类别索引 &lt;cite&gt;(0 到 C-1, 其中 C 是类别数量)&lt;/cite&gt;</p>
<p>该 loss 可以描述为:</p>
<pre class="codehilite"><code class="language-py">loss(x, class) = -x[class]</code></pre>


<p>或者当 weight 参数存在时可以描述为:</p>
<pre class="codehilite"><code class="language-py">loss(x, class) = -weight[class] * x[class]</code></pre>


<p>又或者当 ignore_index 参数存在时可以描述为:</p>
<pre class="codehilite"><code class="language-py">loss(x, class) = class != ignoreIndex ? -weight[class] * x[class] : 0</code></pre>


<p>| Parameters: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – 自定义的每个类别的权重. 必须是一个长度为 &lt;cite&gt;C&lt;/cite&gt; 的 Tensor</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量） 上取平均值. 如果字段 size_average 被设置为 <code>False</code>, loss<code>将会在每个 mini-batch（小批量） 上累加, 而不会取平均值. 当 reduce 的值为</code>False<code>时该字段会被忽略. 默认值:</code>True`</li>
<li><strong>ignore_index</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <em>optional</em>) – 设置一个目标值, 该目标值会被忽略, 从而不会影响到 输入的梯度. 当 size_average 为 <code>True</code> 时, loss 将会在没有被忽略的元素上 取平均值.</li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量）上求平均值或者 求和. 当 reduce 是 <code>False</code> 时, 损失函数会对每个 batch 元素都返回一个 loss 并忽 略 size_average 字段. 默认值: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, C)\)</code>, 其中 &lt;cite&gt;C&lt;/cite&gt; 是类别的数量</li>
<li>目标: <code>\((N)\)</code>, 其中的每个元素都满足 &lt;cite&gt;0 &lt;= targets[i] &lt;= C-1&lt;/cite&gt;</li>
<li>输出: 标量. 如果 reduce 是 <code>False</code>, 则输出为 <code>\((N)\)</code>.</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.LogSoftmax()
&gt;&gt;&gt; loss = nn.NLLLoss()
&gt;&gt;&gt; # input is of size N x C = 3 x 5
&gt;&gt;&gt; input = autograd.Variable(torch.randn(3, 5), requires_grad=True)
&gt;&gt;&gt; # each element in target has to have 0 &lt;= value &lt; C
&gt;&gt;&gt; target = autograd.Variable(torch.LongTensor([1, 0, 4]))
&gt;&gt;&gt; output = loss(m(input), target)
&gt;&gt;&gt; output.backward()</code></pre>


<h3 id="poissonnllloss">PoissonNLLLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.PoissonNLLLoss(log_input=True, full=False, size_average=True, eps=1e-08)</code></pre>


<p>目标值为泊松分布的负对数似然损失.</p>
<p>该损失可以描述为:</p>
<blockquote>
<p>target ~ Pois(input) loss(input, target) = input - target * log(input) + log(target!)</p>
</blockquote>
<p>最后一项可以被省略或者用 Stirling 公式来近似. 该近似用于大于1的目标值. 当目标值 小于或等于1时, 则将0加到 loss 中.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>log_input</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果设置为 <code>True</code> , loss 将会按照公 式 &lt;cite&gt;exp(input) - target * input&lt;/cite&gt; 来计算, 如果设置为 <code>False</code> , loss 将会按照 &lt;cite&gt;input - target * log(input+eps)&lt;/cite&gt; 计算.</li>
<li><strong>full</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 是否计算全部的 loss, i. e. 加上 Stirling 近似项 &lt;cite&gt;target * log(target) - target + 0.5 * log(2 * pi * target)&lt;/cite&gt;.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量） 上取平均值. 如果字段 size_average 被设置为 <code>False</code>, loss 将会在每个 mini-batch（小批量） 上累加, 而不会取平均值.</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a><em>,</em> <em>optional</em>) – 当 log_input==<code>False</code> 时, 取一个很小的值用来避免计算 log(0). 默认值: 1e-8</li>
</ul>
<p>|
| --- | --- |</p>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; loss = nn.PoissonNLLLoss()
&gt;&gt;&gt; log_input = autograd.Variable(torch.randn(5, 2), requires_grad=True)
&gt;&gt;&gt; target = autograd.Variable(torch.randn(5, 2))
&gt;&gt;&gt; output = loss(log_input, target)
&gt;&gt;&gt; output.backward()</code></pre>


<h3 id="nllloss2d">NLLLoss2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.NLLLoss2d(weight=None, size_average=True, ignore_index=-100, reduce=True)</code></pre>


<p>对于图片输入的负对数似然损失. 它计算每个像素的负对数似然损失.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – 自定义的每个类别的权重. 必须是一个长度为 &lt;cite&gt;C&lt;/cite&gt; 的 Tensor</li>
<li><strong>size_average</strong> – 默认情况下, loss 会在每个 mini-batch（小批量） 上取平均值. 如果字段 size_average 被设置为 <code>False</code>, loss 将会在每个 mini-batch（小批量） 上累加, 而不会取平均值. 当 reduce 的值为 <code>False</code> 时该字段会被忽略. 默认值: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量）上求平均值或者 求和. 当 reduce 是 <code>False</code> 时, 损失函数会对每个 batch 元素都返回一个 loss 并忽 略 size_average 字段. 默认值: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H, W)\)</code> where &lt;cite&gt;C = number of classes&lt;/cite&gt;</li>
<li>Target: <code>\((N, H, W)\)</code> where each value is &lt;cite&gt;0 &lt;= targets[i] &lt;= C-1&lt;/cite&gt;</li>
<li>Output: scalar. If reduce is <code>False</code>, then <code>\((N, H, W)\)</code> instead.</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Conv2d(16, 32, (3, 3)).float()
&gt;&gt;&gt; loss = nn.NLLLoss2d()
&gt;&gt;&gt; # input is of size N x C x height x width
&gt;&gt;&gt; input = autograd.Variable(torch.randn(3, 16, 10, 10))
&gt;&gt;&gt; # each element in target has to have 0 &lt;= value &lt; C
&gt;&gt;&gt; target = autograd.Variable(torch.LongTensor(3, 8, 8).random_(0, 4))
&gt;&gt;&gt; output = loss(m(input), target)
&gt;&gt;&gt; output.backward()</code></pre>


<h3 id="kldivloss">KLDivLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.KLDivLoss(size_average=True, reduce=True)</code></pre>


<p><a href="https://en.wikipedia.org/wiki/Kullback-Leibler_divergence">Kullback-Leibler divergence</a> 损失</p>
<p>KL 散度可用于衡量不同的连续分布之间的距离, 在连续的输出分布的空间上(离散采样)上进行直接回归时 很有效.</p>
<p>跟 &lt;cite&gt;NLLLoss&lt;/cite&gt; 一样, &lt;cite&gt;input&lt;/cite&gt; 需要含有 <em>对数概率</em> , 不同于 &lt;cite&gt;ClassNLLLoss&lt;/cite&gt;, &lt;cite&gt;input&lt;/cite&gt; 可 以不是2维的 Tensor, 因为该函数会逐元素地求值.</p>
<p>该方法需要一个shape跟 &lt;cite&gt;input&lt;/cite&gt; &lt;cite&gt;Tensor&lt;/cite&gt; 一样的 &lt;cite&gt;target&lt;/cite&gt; &lt;cite&gt;Tensor&lt;/cite&gt;.</p>
<p>损失可以描述为:</p>
<pre class="codehilite"><code class="language-py">\[loss(x, target) = 1/n \sum(target_i * (log(target_i) - x_i))\]</code></pre>


<p>默认情况下, loss 会在每个 mini-batch（小批量）上和 <strong>维度</strong> 上取平均值. 如果字段 &lt;cite&gt;size_average&lt;/cite&gt; 设置为 <code>False</code>, 则 loss 不会取平均值.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量）上 和 <strong>维度</strong> 上取平均值. 如果设置为 <code>False</code>, 则 loss 会累加, 而不是取平均值.</li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会根据 size_average 在每 个 mini-batch（小批量）上求平均值或者求和. 当 reduce 是 <code>False</code> 时, 损失函数会对每 个 batch 元素都返回一个 loss 并忽略 size_average 字段. 默认值: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, *)\)</code>, 其中 &lt;cite&gt;*&lt;/cite&gt; 表示任意数量的额外维度.</li>
<li>目标: <code>\((N, *)\)</code>, shape 跟输入相同</li>
<li>输出: 标量. 如果 &lt;cite&gt;reduce&lt;/cite&gt; 是 <code>True</code>, 则输出为 <code>\((N, *)\)</code>, shape 跟输入相同.</li>
</ul>
<h3 id="bceloss">BCELoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.BCELoss(weight=None, size_average=True)</code></pre>


<p>计算目标和输出之间的二进制交叉熵:</p>
<pre class="codehilite"><code class="language-py">\[loss(o, t) = - 1/n \sum_i (t[i] * log(o[i]) + (1 - t[i]) * log(1 - o[i]))\]</code></pre>


<p>当定义了 weight 参数时:</p>
<pre class="codehilite"><code class="language-py">\[loss(o, t) = - 1/n \sum_i weight[i] * (t[i] * log(o[i]) + (1 - t[i]) * log(1 - o[i]))\]</code></pre>


<p>这可用于测量重构的误差, 例如自动编码机. 注意目标的值 &lt;cite&gt;t[i]&lt;/cite&gt; 的范围为0到1之间.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – 自定义的每个 batch 元素的 loss 的权重. 必须是一个长度为 “nbatch” 的 的 Tensor</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量） 上取平均值. 如果字段 size_average 被设置为 <code>False</code> , loss 会在每 个 mini-batch（小批量）上累加, 而不是取平均值. 默认值: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, *)\)</code>, 其中 &lt;cite&gt;*&lt;/cite&gt; 表示任意数量的额外维度.</li>
<li>目标: <code>\((N, *)\)</code>, shape 跟输入相同</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = nn.Sigmoid()
&gt;&gt;&gt; loss = nn.BCELoss()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(3), requires_grad=True)
&gt;&gt;&gt; target = autograd.Variable(torch.FloatTensor(3).random_(2))
&gt;&gt;&gt; output = loss(m(input), target)
&gt;&gt;&gt; output.backward()</code></pre>


<h3 id="bcewithlogitsloss">BCEWithLogitsLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.BCEWithLogitsLoss(weight=None, size_average=True)</code></pre>


<p>该损失函数把 &lt;cite&gt;Sigmoid&lt;/cite&gt; 层集成到了 &lt;cite&gt;BCELoss&lt;/cite&gt; 类中. 该版比用一个简单的 &lt;cite&gt;Sigmoid&lt;/cite&gt; 层和 &lt;cite&gt;BCELoss&lt;/cite&gt; 在数值上更稳定, 因为把这两个操作合并为一个层之后, 可以利用 log-sum-exp 的 技巧来实现数值稳定.</p>
<p>目标和输出之间的二值交叉熵(不含sigmoid函数)是:</p>
<pre class="codehilite"><code class="language-py">\[loss(o, t) = - 1/n \sum_i (t[i] * log(sigmoid(o[i])) + (1 - t[i]) * log(1 - sigmoid(o[i])))\]</code></pre>


<p>当定义了 weight 参数之后可描述为:</p>
<pre class="codehilite"><code class="language-py">\[loss(o, t) = - 1/n \sum_i weight[i] * (t[i] * log(sigmoid(o[i])) + (1 - t[i]) * log(1 - sigmoid(o[i])))\]</code></pre>


<p>这可用于测量重构的误差, 例如自动编码机. 注意目标的值 &lt;cite&gt;t[i]&lt;/cite&gt; 的范围为0到1之间.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – 自定义的每个 batch 元素的 loss 的权重. 必须是一个长度 为 “nbatch” 的 Tensor</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 默认情况下, loss 会在每个 mini-batch（小批量） 上取平均值. 如果字段 size_average 被设置为 <code>False</code> , loss 会在每 个 mini-batch（小批量）上累加, 而不是取平均值. 默认值: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, *)\)</code>, 其中 &lt;cite&gt;*&lt;/cite&gt; 表示任意数量的额外维度.</li>
<li>目标: <code>\((N, *)\)</code>, shape 跟输入相同</li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; loss = nn.BCEWithLogitsLoss()
&gt;&gt;&gt; input = autograd.Variable(torch.randn(3), requires_grad=True)
&gt;&gt;&gt; target = autograd.Variable(torch.FloatTensor(3).random_(2))
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()</code></pre>


<h3 id="marginrankingloss">MarginRankingLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MarginRankingLoss(margin=0, size_average=True)</code></pre>


<p>创建一个衡量 mini-batch(小批量) 中的2个1维 &lt;cite&gt;Tensor&lt;/cite&gt; 的输入 &lt;cite&gt;x1&lt;/cite&gt; 和 &lt;cite&gt;x2&lt;/cite&gt;, 和1个1维 &lt;cite&gt;Tensor&lt;/cite&gt; 的目标 &lt;cite&gt;y<code>(</code>y&lt;/cite&gt; 的取值是 &lt;cite&gt;1&lt;/cite&gt; 或者 &lt;cite&gt;-1&lt;/cite&gt;) 之间损失的标准.</p>
<p>如果 &lt;cite&gt;y == 1&lt;/cite&gt; 则认为第一个输入值应该排列在第二个输入值之上(即值更大), &lt;cite&gt;y == -1&lt;/cite&gt; 时则相反.</p>
<p>对于 mini-batch(小批量) 中每个实例的损失函数如下:</p>
<pre class="codehilite"><code class="language-py">loss(x, y) = max(0, -y * (x1 - x2) + margin)</code></pre>


<p>如果内部变量 &lt;cite&gt;size_average = True&lt;/cite&gt;, 则损失函数计算批次中所有实例的损失值的平均值; 如果 &lt;cite&gt;size_average = False&lt;/cite&gt;, 则损失函数计算批次中所有实例的损失至的合计. &lt;cite&gt;size_average&lt;/cite&gt; 默认值为 <code>True</code>.</p>
<h3 id="hingeembeddingloss">HingeEmbeddingLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.HingeEmbeddingLoss(margin=1.0, size_average=True)</code></pre>


<p>衡量输入 Tensor(张量) &lt;cite&gt;x&lt;/cite&gt; 和 目标 Tensor(张量) &lt;cite&gt;y&lt;/cite&gt; (取值为 &lt;cite&gt;1&lt;/cite&gt; 和 &lt;cite&gt;-1&lt;/cite&gt;) 之间的损失值. 此方法通常用来衡量两个输入值是否相似, 例如使用L1成对距离作为 &lt;cite&gt;x&lt;/cite&gt;, 并且通常用来进行非线性嵌入学习或者 半监督学习:</p>
<pre class="codehilite"><code class="language-py">                 { x_i,                  if y_i ==  1
loss(x, y) = 1/n {
                 { max(0, margin - x_i), if y_i == -1</code></pre>


<p>&lt;cite&gt;x&lt;/cite&gt; 和 &lt;cite&gt;y&lt;/cite&gt; 分别可以是具有 &lt;cite&gt;n&lt;/cite&gt; 个元素的任意形状. 合计操作对所有元素进行计算.</p>
<p>如果 &lt;cite&gt;size_average=False&lt;/cite&gt;, 则计算时不会除以 &lt;cite&gt;n&lt;/cite&gt; 取平均值.</p>
<p>&lt;cite&gt;margin&lt;/cite&gt; 的默认值是 &lt;cite&gt;1&lt;/cite&gt;, 或者可以通过构造函数来设置.</p>
<h3 id="multilabelmarginloss">MultiLabelMarginLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MultiLabelMarginLoss(size_average=True)</code></pre>


<p>创建一个标准, 用以优化多元分类问题的合页损失函数 (基于空白的损失), 计算损失值时 需要2个参数分别为输入, &lt;cite&gt;x&lt;/cite&gt; (一个2维小批量 &lt;cite&gt;Tensor&lt;/cite&gt;) 和输出 &lt;cite&gt;y&lt;/cite&gt; (一个2维 &lt;cite&gt;Tensor&lt;/cite&gt;, 其值为 &lt;cite&gt;x&lt;/cite&gt; 的索引值). 对于mini-batch(小批量) 中的每个样本按如下公式计算损失:</p>
<pre class="codehilite"><code class="language-py">loss(x, y) = sum_ij(max(0, 1 - (x[y[j]] - x[i]))) / x.size(0)</code></pre>


<p>其中 &lt;cite&gt;i&lt;/cite&gt; 的取值范围是 &lt;cite&gt;0&lt;/cite&gt; 到 &lt;cite&gt;x.size(0)&lt;/cite&gt;, &lt;cite&gt;j&lt;/cite&gt; 的取值范围是 &lt;cite&gt;0&lt;/cite&gt; 到 &lt;cite&gt;y.size(0)&lt;/cite&gt;, &lt;cite&gt;y[j] &gt;= 0&lt;/cite&gt;, 并且对于所有 &lt;cite&gt;i&lt;/cite&gt; 和 &lt;cite&gt;j&lt;/cite&gt; 有 &lt;cite&gt;i != y[j]&lt;/cite&gt;.</p>
<p>&lt;cite&gt;y&lt;/cite&gt; 和 &lt;cite&gt;x&lt;/cite&gt; 必须有相同的元素数量.</p>
<p>此标准仅考虑 &lt;cite&gt;y[j]&lt;/cite&gt; 中最先出现的非零值.</p>
<p>如此可以允许每个样本可以有数量不同的目标类别.</p>
<h3 id="smoothl1loss">SmoothL1Loss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.SmoothL1Loss(size_average=True, reduce=True)</code></pre>


<p>创建一个标准, 当某个元素的错误值的绝对值小于1时使用平方项计算, 其他情况则使用L1范式计算. 此方法创建的标准对于异常值不如 [<code>](#id31)MSELoss</code>敏感, 但是同时在某些情况下可以防止梯度爆炸 (比如 参见论文 “Fast R-CNN” 作者 Ross Girshick). 也被称为 Huber 损失函数:</p>
<pre class="codehilite"><code class="language-py">                      { 0.5 * (x_i - y_i)^2, if |x_i - y_i| &lt; 1
loss(x, y) = 1/n \sum {
                      { |x_i - y_i| - 0.5,   otherwise</code></pre>


<p>&lt;cite&gt;x&lt;/cite&gt; 和 &lt;cite&gt;y&lt;/cite&gt; 可以是任意形状只要都具备总计 &lt;cite&gt;n&lt;/cite&gt; 个元素 合计仍然针对所有元素进行计算, 并且最后除以 &lt;cite&gt;n&lt;/cite&gt;.</p>
<p>如果把内部变量 &lt;cite&gt;size_average&lt;/cite&gt; 设置为 <code>False</code>, 则不会被除以 &lt;cite&gt;n&lt;/cite&gt;.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 损失值默认会按照所有元素取平均值. 但是, 如果 size_average 被 设置为 <code>False</code>, 则损失值为所有元素的合计. 如果 reduce 参数设为 <code>False</code>, 则忽略此参数的值. 默认: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 损失值默认会按照所有元素取平均值或者取合计值. 当 reduce 设置为 <code>False</code> 时, 损失函数对于每个元素都返回损失值并且忽略 size_average 参数. 默认: <code>True</code></li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, *)\)</code> &lt;cite&gt;*&lt;/cite&gt; 代表任意个其他维度</li>
<li>目标: <code>\((N, *)\)</code>, 同输入</li>
<li>输出: 标量. 如果 reduce 设为 <code>False</code> 则为 <code>\((N, *)\)</code>, 同输入</li>
</ul>
<h3 id="softmarginloss">SoftMarginLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.SoftMarginLoss(size_average=True)</code></pre>


<p>创建一个标准, 用以优化两分类的 logistic loss. 输入为 &lt;cite&gt;x&lt;/cite&gt; (一个2维 mini-batch Tensor)和 目标 &lt;cite&gt;y&lt;/cite&gt; (一个包含 &lt;cite&gt;1&lt;/cite&gt; 或者 &lt;cite&gt;-1&lt;/cite&gt; 的 Tensor).</p>
<pre class="codehilite"><code class="language-py">loss(x, y) = sum_i (log(1 + exp(-y[i]*x[i]))) / x.nelement()</code></pre>


<p>可以通过设置 &lt;cite&gt;self.size_average&lt;/cite&gt; 为 <code>False</code> 来禁用按照元素数量取平均的正则化操作.</p>
<h3 id="multilabelsoftmarginloss">MultiLabelSoftMarginLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MultiLabelSoftMarginLoss(weight=None, size_average=True)</code></pre>


<p>创建一个标准, 基于输入 &lt;cite&gt;x&lt;/cite&gt; 和目标 &lt;cite&gt;y<code>的 max-entropy(最大熵), 优化多标签 one-versus-all 损失. 输入</code>x&lt;/cite&gt; 为一个2维 mini-batch &lt;cite&gt;Tensor&lt;/cite&gt;, 目标 &lt;cite&gt;y&lt;/cite&gt; 为2进制2维 &lt;cite&gt;Tensor&lt;/cite&gt;. 对每个 mini-batch 中的样本, 对应的 loss 为:</p>
<pre class="codehilite"><code class="language-py">loss(x, y) = - sum_i (y[i] * log( 1 / (1 + exp(-x[i])) )
                  + ( (1-y[i]) * log(exp(-x[i]) / (1 + exp(-x[i])) ) )</code></pre>


<p>其中 &lt;cite&gt;i == 0&lt;/cite&gt; 至 &lt;cite&gt;x.nElement()-1&lt;/cite&gt;, &lt;cite&gt;y[i] in {0,1}&lt;/cite&gt;. &lt;cite&gt;y&lt;/cite&gt; 和 &lt;cite&gt;x&lt;/cite&gt; 必须具有相同的维度.</p>
<h3 id="cosineembeddingloss">CosineEmbeddingLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.CosineEmbeddingLoss(margin=0, size_average=True)</code></pre>


<p>新建一个标准, 用以衡量输入 &lt;cite&gt;Tensor&lt;/cite&gt; x1, x2 和取值为 1 或者 -1 的标签 &lt;cite&gt;Tensor&lt;/cite&gt; [<code>](#id33)y</code>之间的 损失值. 此标准用 cosine 距离来衡量2个输入参数之间是否相似, 并且一般用来学习非线性 embedding 或者半监督 学习.</p>
<p>&lt;cite&gt;margin&lt;/cite&gt; 应该取 &lt;cite&gt;-1&lt;/cite&gt; 到 &lt;cite&gt;1&lt;/cite&gt; 之间的值, 建议取值范围是 &lt;cite&gt;0&lt;/cite&gt; 到 &lt;cite&gt;0.5&lt;/cite&gt;. 如果没有设置 &lt;cite&gt;margin&lt;/cite&gt; 参数, 则默认值取 &lt;cite&gt;0&lt;/cite&gt;.</p>
<p>每个样本的损失函数如下:</p>
<pre class="codehilite"><code class="language-py">             { 1 - cos(x1, x2),              if y ==  1
loss(x, y) = {
             { max(0, cos(x1, x2) - margin), if y == -1</code></pre>


<p>如果内部变量 &lt;cite&gt;size_average&lt;/cite&gt; 设置为 <code>True</code>, 则损失函数以 batch 中所有的样本数取平均值; 如果 &lt;cite&gt;size_average&lt;/cite&gt; 设置为 <code>False</code>, 则损失函数对 batch 中所有的样本求和. 默认情况下, &lt;cite&gt;size_average = True&lt;/cite&gt;.</p>
<h3 id="multimarginloss">MultiMarginLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.MultiMarginLoss(p=1, margin=1, weight=None, size_average=True)</code></pre>


<p>创建一个标准, 用以优化多元分类问题的合页损失函数 (基于空白的损失), 计算损失值时 需要2个参数分别为输入, &lt;cite&gt;x&lt;/cite&gt; (一个2维小批量 &lt;cite&gt;Tensor&lt;/cite&gt;) 和输出 &lt;cite&gt;y&lt;/cite&gt; (一个1维 &lt;cite&gt;Tensor&lt;/cite&gt;, 其值为 &lt;cite&gt;x&lt;/cite&gt; 的索引值, &lt;cite&gt;0&lt;/cite&gt; &lt;= &lt;cite&gt;y&lt;/cite&gt; &lt;= &lt;cite&gt;x.size(1)&lt;/cite&gt;):</p>
<p>对于每个 mini-batch(小批量) 样本:</p>
<pre class="codehilite"><code class="language-py">loss(x, y) = sum_i(max(0, (margin - x[y] + x[i]))^p) / x.size(0)
             其中 `i == 0` 至 `x.size(0)` 并且 `i != y`.</code></pre>


<p>可选择的, 如果您不想所有的类拥有同样的权重的话, 您可以通过在构造函数中传入 &lt;cite&gt;weight&lt;/cite&gt; 参数来 解决这个问题, &lt;cite&gt;weight&lt;/cite&gt; 是一个1维 Tensor.</p>
<p>传入 &lt;cite&gt;weight&lt;/cite&gt; 后, 损失函数变为:</p>
<blockquote>
<p>loss(x, y) = sum_i(max(0, w[y] * (margin - x[y] - x[i]))^p) / x.size(0)</p>
</blockquote>
<p>默认情况下, 求出的损失值会对每个 minibatch 样本的结果取平均. 可以通过设置 &lt;cite&gt;size_average&lt;/cite&gt; 为 <code>False</code> 来用合计操作取代取平均操作.</p>
<h3 id="tripletmarginloss">TripletMarginLoss</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.TripletMarginLoss(margin=1.0, p=2, eps=1e-06, swap=False)</code></pre>


<p>创建一个标准, 用以衡量三元组合的损失值, 计算损失值时需要3个输入张量 &lt;cite&gt;x1&lt;/cite&gt;, &lt;cite&gt;x2&lt;/cite&gt;, &lt;cite&gt;x3&lt;/cite&gt; 和 一个大于零的 &lt;cite&gt;margin&lt;/cite&gt; 值. 此标准可以用来衡量输入样本间的相对相似性. 一个三元输入组合由 &lt;cite&gt;a&lt;/cite&gt;, &lt;cite&gt;p&lt;/cite&gt; 和 &lt;cite&gt;n&lt;/cite&gt;: anchor, positive 样本 和 negative 样本组成. 所有输入变量的形式必须为 <code>\((N, D)\)</code>.</p>
<p>距离交换的详细说明请参考论文 <a href="http://www.iis.ee.ic.ac.uk/%7Evbalnt/shallow_descr/TFeat_paper.pdf">Learning shallow convolutional feature descriptors with triplet losses</a> by V. Balntas, E. Riba et al.</p>
<pre class="codehilite"><code class="language-py">\[L(a, p, n) = \frac{1}{N} \left( \sum_{i=1}^N \max \{d(a_i, p_i) - d(a_i, n_i) + {\rm margin}, 0\} \right)\]</code></pre>


<p>其中 <code>\(d(x_i, y_i) = \left\lVert {\bf x}_i - {\bf y}_i \right\rVert_p\)</code>.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>anchor</strong> – anchor 输入 tensor</li>
<li><strong>positive</strong> – positive 输入 tensor</li>
<li><strong>negative</strong> – negative 输入 tensor</li>
<li><strong>p</strong> – 正则化率. Default: 2</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, D)\)</code> 其中 &lt;cite&gt;D = vector dimension&lt;/cite&gt;</li>
<li>Output: <code>\((N, 1)\)</code></li>
</ul>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; triplet_loss = nn.TripletMarginLoss(margin=1.0, p=2)
&gt;&gt;&gt; input1 = autograd.Variable(torch.randn(100, 128))
&gt;&gt;&gt; input2 = autograd.Variable(torch.randn(100, 128))
&gt;&gt;&gt; input3 = autograd.Variable(torch.randn(100, 128))
&gt;&gt;&gt; output = triplet_loss(input1, input2, input3)
&gt;&gt;&gt; output.backward()</code></pre>


<h2 id="vision-layers">Vision layers (视觉层)</h2>
<h3 id="pixelshuffle">PixelShuffle</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.PixelShuffle(upscale_factor)</code></pre>


<p>对张量中形如 <code>\((*, C * r^2, H, W]\)</code> 的元素, 重新排列成 <code>\((C, H * r, W * r)\)</code>.</p>
<p>当使用 stride = <code>\(1/r\)</code> 的高效子像素卷积很有用.</p>
<p>参考如下论文获得更多信息: <a href="https://arxiv.org/abs/1609.05158">Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network</a> Shi et. al (2016) .</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>upscale_factor</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – 增加空间分辨率的因子</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, C * {upscale\_factor}^2, H, W)\)</code></li>
<li>输出: <code>\((N, C, H * {upscale\_factor}, W * {upscale\_factor})\)</code></li>
</ul>
<p>Examples:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; ps = nn.PixelShuffle(3)
&gt;&gt;&gt; input = autograd.Variable(torch.Tensor(1, 9, 4, 4))
&gt;&gt;&gt; output = ps(input)
&gt;&gt;&gt; print(output.size())
torch.Size([1, 1, 12, 12])</code></pre>


<h3 id="upsample">Upsample</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.Upsample(size=None, scale_factor=None, mode='nearest')</code></pre>


<p>对给定的多通道一维时序数据, 二维空间数据, 或三维容积数据进行上采样.</p>
<p>输入数据的格式为 &lt;cite&gt;minibatch x channels x [depth] x [height] x width&lt;/cite&gt;. 因此, 对于2-D空间数据的输入, 期望得到一个4-D张量；对于3-D立体数据输入, 期望得到一个5-D张量.</p>
<p>对3D, 4D, 5D的输入张量进行最近邻、线性、双线性和三线性采样, 可用于该上采样方法.</p>
<p>可以提供 <code>scale_factor</code> 或目标输出的 <code>size</code> 来计算输出的大小. （不能同时都给, 因为这样做是含糊不清的. ）</p>
<p>| Parameters: | </p>
<ul>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 整型数的元组 ([D_out], [H_out], W_out) 输出大小</li>
<li><strong>scale_factor</strong> (<em>int / tuple of python:ints__,</em> <em>optional</em>) – 图像高度/宽度/深度的乘数</li>
<li><strong>mode</strong> (<a href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.6)"><em>string</em></a><em>,</em> <em>optional</em>) – 上采样算法: nearest &#124; linear &#124; bilinear &#124; trilinear. 默认为: nearest</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>输入: <code>\((N, C, W_{in})\)</code>, <code>\((N, C, H_{in}, W_{in})\)</code> 或 <code>\((N, C, D_{in}, H_{in}, W_{in})\)</code></li>
<li>输出: <code>\((N, C, W_{out})\)</code>, <code>\((N, C, H_{out}, W_{out})\)</code> 或 <code>\((N, C, D_{out}, H_{out}, W_{out})\)</code> 其中: <code>\(D_{out} = floor(D_{in} * scale\_factor)\)</code> 或 &lt;cite&gt;size[-3]&lt;/cite&gt; <code>\(H_{out} = floor(H_{in} * scale\_factor)\)</code> 或 &lt;cite&gt;size[-2]&lt;/cite&gt; <code>\(W_{out} = floor(W_{in} * scale\_factor)\)</code> 或 &lt;cite&gt;size[-1]&lt;/cite&gt;</li>
</ul>
<p>示例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; inp
Variable containing:
(0 ,0 ,.,.) =
 1  2
 3  4
[torch.FloatTensor of size 1x1x2x2]

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='bilinear')
&gt;&gt;&gt; m(inp)
Variable containing:
(0 ,0 ,.,.) =
 1.0000  1.3333  1.6667  2.0000
 1.6667  2.0000  2.3333  2.6667
 2.3333  2.6667  3.0000  3.3333
 3.0000  3.3333  3.6667  4.0000
[torch.FloatTensor of size 1x1x4x4]

&gt;&gt;&gt; inp
Variable containing:
(0 ,0 ,.,.) =
 1  2
 3  4
[torch.FloatTensor of size 1x1x2x2]

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='nearest')
&gt;&gt;&gt; m(inp)
Variable containing:
(0 ,0 ,.,.) =
 1  1  2  2
 1  1  2  2
 3  3  4  4
 3  3  4  4
[torch.FloatTensor of size 1x1x4x4]</code></pre>


<h3 id="upsamplingnearest2d">UpsamplingNearest2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.UpsamplingNearest2d(size=None, scale_factor=None)</code></pre>


<p>对多个输入通道组成的输入信号进行2维最近邻上采样.</p>
<p>为了指定采样范围, 提供了 <code>size</code> 或 <code>scale_factor</code> 作为构造参数.</p>
<p>当给定 &lt;cite&gt;size&lt;/cite&gt;, 输出图像的大小为 (h, w).</p>
<p>| Parameters: | </p>
<ul>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输出图片大小的整型元组(H_out, W_out)</li>
<li><strong>scale_factor</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <em>optional</em>) – 图像的 长和宽的乘子.</li>
</ul>
<p>|
| --- | --- |</p>
<p>Shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> 其中 <code>\(H_{out} = floor(H_{in} * scale\_factor)\)</code> <code>\(W_{out} = floor(W_{in} * scale\_factor)\)</code></li>
</ul>
<p>示例:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; inp
Variable containing:
(0 ,0 ,.,.) =
 1  2
 3  4
[torch.FloatTensor of size 1x1x2x2]

&gt;&gt;&gt; m = nn.UpsamplingNearest2d(scale_factor=2)
&gt;&gt;&gt; m(inp)
Variable containing:
(0 ,0 ,.,.) =
 1  1  2  2
 1  1  2  2
 3  3  4  4
 3  3  4  4
[torch.FloatTensor of size 1x1x4x4]</code></pre>


<h3 id="upsamplingbilinear2d">UpsamplingBilinear2d</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.UpsamplingBilinear2d(size=None, scale_factor=None)</code></pre>


<p>对多个输入通道组成的输入信号进行2维双线性上采样.</p>
<p>为了指定采样范围, 提供了 <code>size</code> 或 <code>scale_factor</code> 作为构造参数.</p>
<p>当给定 &lt;cite&gt;size&lt;/cite&gt;, 输出图像的大小为 (h, w).</p>
<p>| Parameters: | </p>
<ul>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.6)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输出图片大小的整型元组(H_out, W_out)</li>
<li><strong>scale_factor</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <em>optional</em>) – 图像的 长和宽的乘子.</li>
</ul>
<p>|
| --- | --- |</p>
<p>shape:</p>
<ul>
<li>Input: <code>\((N, C, H_{in}, W_{in})\)</code></li>
<li>Output: <code>\((N, C, H_{out}, W_{out})\)</code> 其中 <code>\(H_{out} = floor(H_{in} * scale\_factor)\)</code> <code>\(W_{out} = floor(W_{in} * scale\_factor)\)</code></li>
</ul>
<p>示例:::</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; inp
Variable containing:
(0 ,0 ,.,.) =
 1  2
 3  4
[torch.FloatTensor of size 1x1x2x2]

&gt;&gt;&gt; m = nn.UpsamplingBilinear2d(scale_factor=2)
&gt;&gt;&gt; m(inp)
Variable containing:
(0 ,0 ,.,.) =
 1.0000  1.3333  1.6667  2.0000
 1.6667  2.0000  2.3333  2.6667
 2.3333  2.6667  3.0000  3.3333
 3.0000  3.3333  3.6667  4.0000
[torch.FloatTensor of size 1x1x4x4]</code></pre>


<h2 id="dataparallel-layers-multi-gpu-distributed-gpu">DataParallel layers (multi-GPU, distributed) (数据并行层, 多 GPU 的, 分布式的)</h2>
<h3 id="dataparallel">DataParallel</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.DataParallel(module, device_ids=None, output_device=None, dim=0)</code></pre>


<p>在模块级别实现数据并行性.</p>
<p>此容器通过在批次维度中分块, 将输入分割到指定设备上, 从而并行化给定模块的应用程 序.在正向传递中, 模块被复制到每个设备上, 每个副本处理一部分输入.在向后传递期间, 来自每个副本的梯度变化被汇总到原始模块中.</p>
<p>batch size 应该大于 GPUs 的数量.同时也应该是 GPU 数量的整数倍, 以 便每个块大小相同（以便每个 GPU 处理相同数量的样本）.</p>
<p>引用 :<a href="notes/cuda.html#cuda-nn-dataparallel-instead">使用 nn.DataParallel 替代 multiprocessing</a></p>
<p>允许将任意位置和关键字输入传入 DataParallel EXCEPT Tensors. 所有的变量将被分 散在指定的维度（默认为0）.原始类型将被广播, 但所有其他类型将是一个浅层副本, 如 果写入模型的正向传递, 可能会被损坏.</p>
<p>Args : module: 并行的模型 device_ids: CUDA devices（CUDA 驱动） (default: all devices) output_device: 输出设备位置 (default: device_ids[0]) 示例 ::</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; net = torch.nn.DataParallel(model, device_ids=[0, 1, 2])
&gt;&gt;&gt; output = net(input_var)</code></pre>


<h3 id="distributeddataparallel">DistributedDataParallel</h3>
<pre class="codehilite"><code class="language-py">class torch.nn.parallel.DistributedDataParallel(module, device_ids=None, output_device=None, dim=0)</code></pre>


<p>在模块级别实现分布式数据并行.</p>
<p>此容器通过在批次维度中分块, 将输入分割到指定设备上, 从而并行化给定模块的应用程序. 该模块被复制到每台机器和每个设备上, 每个这样的副本处理一部分输入.在向后传递期间, 来自每个节点的梯度被平均.</p>
<p>batch size 应该大于 GPUs 的数量.同时也应该是 GPU 数量的整数倍, 以便每个块大小 相同（以便每个 GPU 处理相同数量的样本）.</p>
<p>引用 :<a href="distributed.html#distributed-basics">Basics</a> 和 <a href="notes/cuda.html#cuda-nn-dataparallel-instead">使用 nn.DataParallel 替代 multiprocessing</a>. 对输入的约束和 <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>torch.nn.DataParallel</code></a> 中一样.</p>
<p>创建这个类需要分布式包已经在 process group 模式下被初始化 (引用 <a href="distributed.html#torch.distributed.init_process_group" title="torch.distributed.init_process_group"><code>torch.distributed.init_process_group()</code></a>).</p>
<p>Warning</p>
<p>这个模块只能和<code>gloo</code>后端一起工作.</p>
<p>Warning</p>
<p>构造器, 转发方法和输出（或者这个模块的输出功能）的区分是分布式同步点.考虑到不同的 进程可能会执行不同的代码.</p>
<p>Warning</p>
<p>该模块假设所有参数在创建时都在模型中注册.之后不应该添加或删除参数.同样适用于缓冲区.</p>
<p>Warning</p>
<p>这个模块假定所有的缓冲区和梯度都是密集的.</p>
<p>Warning</p>
<p>这个模块不能用于 : func: &lt;cite&gt;torch.autograd.grad&lt;/cite&gt; （即只有在参数的 <code>.grad</code> 属性中 累积梯度才能使用）.</p>
<p>Note</p>
<p>参数永远不会在进程之间广播.模块在梯度上执行全部优化步骤, 并假定它们将以相同的方式在 所有进程中进行优化.缓冲区（e.g. BatchNorm stats）在等级0的过程中从模块广播到系统 中的每个迭代中的所有其他副本.</p>
<p>Args : module: 需要并行的模型 device_ids: CUDA devices (default: all devices) output_device: device location of output (default: device_ids[0]) 示例 ::</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; torch.distributed.init_process_group(world_size=4, init_method='...')
&gt;&gt;&gt; net = torch.nn.DistributedDataParallel(model)</code></pre>


<h2 id="utilities">Utilities (工具包)</h2>
<h3 id="clip_grad_norm">clip_grad_norm</h3>
<pre class="codehilite"><code class="language-py">torch.nn.utils.clip_grad_norm(parameters, max_norm, norm_type=2)</code></pre>


<p>接收一个包含 Variable 的可迭代对象, 对 Variable 的梯度按范数进行裁剪.</p>
<p>范数是对所有梯度进行计算的, 等价于把所有输入变量的梯度连接成一个向量, 然后对这个向量按范数进行裁剪. 梯度将会被原地修改.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>parameters</strong> (<em>Iterable__[</em><a href="autograd.html#torch.autograd.Variable" title="torch.autograd.Variable"><em>Variable</em></a><em>]</em>) – 一个可迭代对象, 其包含将要进行梯度正规化的 Variable</li>
<li><strong>max_norm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – 梯度的最大范数</li>
<li><strong>norm_type</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a>) – p 范数(指定 p ). 用 <code>'inf'</code> 表示无穷范数</li>
</ul>
<p>|
| --- | --- |
| Returns: | 梯度的范数 (视为单个向量的). |
| --- | --- |</p>
<h3 id="weight_norm">weight_norm</h3>
<pre class="codehilite"><code class="language-py">torch.nn.utils.weight_norm(module, name='weight', dim=0)</code></pre>


<p>将权重归一化应用于给定模块中的指定参数. .</p>
<pre class="codehilite"><code class="language-py">\[\mathbf{w} = g \dfrac{\mathbf{v}}{\|\mathbf{v}\|}\]</code></pre>


<p>权重归一化是将权重张量的大小和方向分离的再参数化. 该函数会用两个参数代替 &lt;cite&gt;name&lt;/cite&gt; (e.g. “weight”)所指定的参数. 在新的参数中, 一个指定参数的大小 (e.g. “weight_g”), 一个指定参数的方向. 权重归一化是通过一个钩子实现的, 该钩子会在 &lt;cite&gt;~Module.forward&lt;/cite&gt; 的每次调用之前根据大小和方向(两个新参数)重新计算权重张量.</p>
<p>默认情况下, &lt;cite&gt;dim=0&lt;/cite&gt;, 范数会在每一个输出的 channel/plane 上分别计算. 若要对整个权重张量计算范数, 使用 &lt;cite&gt;dim=None&lt;/cite&gt;.</p>
<p>参见 <a href="https://arxiv.org/abs/1602.07868">https://arxiv.org/abs/1602.07868</a></p>
<p>| Parameters: | </p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – 给定的 module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a><em>,</em> <em>optional</em>) – 权重参数的 name</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>,</em> <em>optional</em>) – 进行范数计算的维度</li>
</ul>
<p>|
| --- | --- |
| Returns: | 添加了权重归一化钩子的原 module |
| --- | --- |</p>
<p>Example:</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = weight_norm(nn.Linear(20, 40), name='weight')
Linear (20 -&gt; 40)
&gt;&gt;&gt; m.weight_g.size()
torch.Size([40, 1])
&gt;&gt;&gt; m.weight_v.size()
torch.Size([40, 20])</code></pre>


<h3 id="remove_weight_norm">remove_weight_norm</h3>
<pre class="codehilite"><code class="language-py">torch.nn.utils.remove_weight_norm(module, name='weight')</code></pre>


<p>从模块中移除权重归一化/再参数化.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – 给定的 module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><em>str</em></a><em>,</em> <em>optional</em>) – 权重参数的 name</li>
</ul>
<p>|
| --- | --- |</p>
<p>Example</p>
<pre class="codehilite"><code class="language-py">&gt;&gt;&gt; m = weight_norm(nn.Linear(20, 40))
&gt;&gt;&gt; remove_weight_norm(m)</code></pre>


<h3 id="packedsequence">PackedSequence</h3>
<pre class="codehilite"><code class="language-py">torch.nn.utils.rnn.PackedSequence(_cls, data, batch_sizes)</code></pre>


<p>保存一个打包序列的 data 和 batch_sizes.</p>
<p>所有的 RNN 模块都接收这种被包裹后的序列作为它们的输入.</p>
<p>Note</p>
<p>永远不要手动创建这个类的实例. 它们应当被 <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>pack_padded_sequence()</code></a> 这样的函数实例化.</p>
<p>| Variables: | </p>
<ul>
<li><strong>data</strong> (<a href="autograd.html#torch.autograd.Variable" title="torch.autograd.Variable"><em>Variable</em></a>) – 包含打包后序列的 Variable</li>
<li><strong>batch_sizes</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.6)"><em>list</em></a><em>[</em><a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>]</em>) – 包含每个序列步的 batch size 的列表</li>
</ul>
<p>|
| --- | --- |</p>
<h3 id="pack_padded_sequence">pack_padded_sequence</h3>
<pre class="codehilite"><code class="language-py">torch.nn.utils.rnn.pack_padded_sequence(input, lengths, batch_first=False)</code></pre>


<p>将填充过的变长序列打包(压紧).</p>
<p>输入的形状可以是 <code>TxBx*</code> . T是最长序列长度(等于 <code>lengths[0]</code>), B 是 batch size, <a href="#id35">*</a>代表任意维度(可以是0). 如果 <code>batch_first=True</code> , 那么相应的 input size 就是 <code>BxTx*</code> .</p>
<p>Variable 中保存的序列, 应该按序列长度的长短排序, 长的在前, 短的在后. 即 input[:,0] 代表的是最长的序列, input[:, B-1] 保存的是最短的序列.</p>
<p>Note</p>
<p>只要是维度大于等于2的 input 都可以作为这个函数的参数. 你可以用它来打包 labels, 然后用 RNN 的输出和打包后的 labels 来计算 loss. 通过 <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> 对象的 <code>.data</code> 属性可以获取 Variable.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>input</strong> (<a href="autograd.html#torch.autograd.Variable" title="torch.autograd.Variable"><em>Variable</em></a>) – 变长序列被填充后的 batch</li>
<li><strong>lengths</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.6)"><em>list</em></a><em>[</em><a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.6)"><em>int</em></a><em>]</em>) – Variable 中每个序列的长度.</li>
<li><strong>batch_first</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果是 <code>True</code>, input 的形状应该是 BxTx*.</li>
</ul>
<p>|
| --- | --- |
| Returns: | 一个 <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> 对象. |
| --- | --- |</p>
<h3 id="pad_packed_sequence">pad_packed_sequence</h3>
<pre class="codehilite"><code class="language-py">torch.nn.utils.rnn.pad_packed_sequence(sequence, batch_first=False, padding_value=0.0)</code></pre>


<p>填充打包过的变长序列.</p>
<p>这是 <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>pack_padded_sequence()</code></a> 的逆操作.</p>
<p>返回的 Varaible 的值的 size 是 TxBx<em>, T 是最长序列的长度, B 是 batch_size, 如果 <code>batch_first=True</code>, 那么返回值是 BxTx</em>.</p>
<p>Batch中的元素将会以它们长度的逆序排列.</p>
<p>| Parameters: | </p>
<ul>
<li><strong>sequence</strong> (<a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><em>PackedSequence</em></a>) – 将要被填充的 batch</li>
<li><strong>batch_first</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.6)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果为 &lt;cite&gt;True`&lt;/cite&gt; , 返回的数据的格式为 BxTx*.</li>
<li><strong>padding_value</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.6)"><em>float</em></a><em>,</em> <em>optional</em>) – 用来填充元素的值</li>
</ul>
<p>|
| --- | --- |
| Returns: | 一个 tuple, 包含被填充后的序列, 和 batch 中序列的长度列表. |
| --- | --- |</p>
                
                  
                
              
              
                


              

              <hr/>
              <div align="center">
                  <p><a href="http://www.apachecn.org/" target="_blank"><font face="KaiTi" size="6" color="red">我们一直在努力</font></a><p>
                  <p><a href="https://github.com/apachecn/pytorch-doc-zh/" target="_blank">apachecn/pytorch-doc-zh</a></p>
                  <p><iframe align="middle" src="https://ghbtns.com/github-btn.html?user=apachecn&repo=pytorch-doc-zh&type=watch&count=true&v=2" frameborder="0" scrolling="0" width="100px" height="25px"></iframe>
                  <iframe align="middle" src="https://ghbtns.com/github-btn.html?user=apachecn&repo=pytorch-doc-zh&type=star&count=true" frameborder="0" scrolling="0" width="100px" height="25px"></iframe>
                  <iframe align="middle" src="https://ghbtns.com/github-btn.html?user=apachecn&repo=pytorch-doc-zh&type=fork&count=true" frameborder="0" scrolling="0" width="100px" height="25px"></iframe>
                  <a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=bcee938030cc9e1552deb3bd9617bbbf62d3ec1647e4b60d9cd6b6e8f78ddc03"><img border="0" src="//pub.idqqimg.com/wpa/images/group.png" alt="ML | ApacheCN" title="ML | ApacheCN"></a></p>
                  <div style="text-align:center;margin:0 0 10.5px;"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                        <ins class="adsbygoogle"
                             style="display:inline-block;width:728px;height:90px"
                             data-ad-client="ca-pub-3565452474788507"
                             data-ad-slot="2543897000"></ins>
                        <script>
                        (adsbygoogle = window.adsbygoogle || []).push({});
                        </script></div>
              </div>

              <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
              <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
              <div id="gitalk-container" class="container-fluid"></div>
              <script type="text/javascript">
                  var gitalk = new Gitalk({
                  clientID: 'f27b87eb424ba43df978',
                  clientSecret: '9b3482a495c5257a1d269d8108b9bfd71f048c3c',
                  repo: 'pytorch-doc-zh',
                  owner: 'apachecn',
                  admin: ['jiangzhonglian'],
                  id: md5(location.pathname),
                  distractionFreeMode: false
                  })
                  gitalk.render('gitalk-container')
              </script>
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../56/" title="torch.Storage" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  后退
                </span>
                torch.Storage
              </span>
            </div>
          </a>
        
        
          <a href="../58/" title="torch.optim" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  前进
                </span>
                torch.optim
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.583bbe55.js"></script>
      
        
        
          
          <script src="../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
                <script src="../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../assets/javascripts/lunr/lunr.jp.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
    
      
    
  </body>
</html>